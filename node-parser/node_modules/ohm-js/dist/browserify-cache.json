{"modules":{"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/index.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/index.js","source":"'use strict';\n\nmodule.exports = require('./is-implemented')() ? Symbol : require('./polyfill');\n","deps":{"./is-implemented":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/is-implemented.js","./polyfill":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/polyfill.js"},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/index.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/index.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/is-implemented.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/is-implemented.js","source":"'use strict';\n\nmodule.exports = function () {\n\tvar symbol;\n\tif (typeof Symbol !== 'function') return false;\n\tsymbol = Symbol('test symbol');\n\ttry { String(symbol); } catch (e) { return false; }\n\tif (typeof Symbol.iterator === 'symbol') return true;\n\n\t// Return 'true' for polyfills\n\tif (typeof Symbol.isConcatSpreadable !== 'object') return false;\n\tif (typeof Symbol.iterator !== 'object') return false;\n\tif (typeof Symbol.toPrimitive !== 'object') return false;\n\tif (typeof Symbol.toStringTag !== 'object') return false;\n\tif (typeof Symbol.unscopables !== 'object') return false;\n\n\treturn true;\n};\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/is-implemented.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/is-implemented.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/is-symbol.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/is-symbol.js","source":"'use strict';\n\nmodule.exports = function (x) {\n\treturn (x && ((typeof x === 'symbol') || (x['@@toStringTag'] === 'Symbol'))) || false;\n};\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/is-symbol.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/is-symbol.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/d/index.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/d/index.js","source":"'use strict';\n\nvar assign        = require('es5-ext/object/assign')\n  , normalizeOpts = require('es5-ext/object/normalize-options')\n  , isCallable    = require('es5-ext/object/is-callable')\n  , contains      = require('es5-ext/string/#/contains')\n\n  , d;\n\nd = module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif ((arguments.length < 2) || (typeof dscr !== 'string')) {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (dscr == null) {\n\t\tc = w = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t\tw = contains.call(dscr, 'w');\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== 'string') {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (get == null) {\n\t\tget = undefined;\n\t} else if (!isCallable(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (set == null) {\n\t\tset = undefined;\n\t} else if (!isCallable(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (dscr == null) {\n\t\tc = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n","deps":{"es5-ext/object/normalize-options":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/normalize-options.js","es5-ext/object/is-callable":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/is-callable.js","es5-ext/string/#/contains":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/index.js","es5-ext/object/assign":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/index.js"},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/d/index.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/d/index.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/index.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/index.js","source":"'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? Object.assign\n\t: require('./shim');\n","deps":{"./is-implemented":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/is-implemented.js","./shim":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/shim.js"},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/index.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/object/assign/index.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/is-implemented.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/is-implemented.js","source":"'use strict';\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== 'function') return false;\n\tobj = { foo: 'raz' };\n\tassign(obj, { bar: 'dwa' }, { trzy: 'trzy' });\n\treturn (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';\n};\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/is-implemented.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/object/assign/is-implemented.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/shim.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/shim.js","source":"'use strict';\n\nvar keys  = require('../keys')\n  , value = require('../valid-value')\n\n  , max = Math.max;\n\nmodule.exports = function (dest, src/*, â€¦srcn*/) {\n\tvar error, i, l = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry { dest[key] = src[key]; } catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < l; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n","deps":{"../valid-value":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/valid-value.js","../keys":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/index.js"},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/shim.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/object/assign/shim.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/is-callable.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/is-callable.js","source":"// Deprecated\n\n'use strict';\n\nmodule.exports = function (obj) { return typeof obj === 'function'; };\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/is-callable.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/object/is-callable.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/index.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/index.js","source":"'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? Object.keys\n\t: require('./shim');\n","deps":{"./shim":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/shim.js","./is-implemented":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/is-implemented.js"},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/index.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/object/keys/index.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/is-implemented.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/is-implemented.js","source":"'use strict';\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys('primitive');\n\t\treturn true;\n\t} catch (e) { return false; }\n};\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/is-implemented.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/object/keys/is-implemented.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/shim.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/shim.js","source":"'use strict';\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) {\n\treturn keys(object == null ? object : Object(object));\n};\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/shim.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/object/keys/shim.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/normalize-options.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/normalize-options.js","source":"'use strict';\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\nmodule.exports = function (options/*, â€¦options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (options == null) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/normalize-options.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/object/normalize-options.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/valid-value.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/valid-value.js","source":"'use strict';\n\nmodule.exports = function (value) {\n\tif (value == null) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/valid-value.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/object/valid-value.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/index.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/index.js","source":"'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? String.prototype.contains\n\t: require('./shim');\n","deps":{"./is-implemented":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/is-implemented.js","./shim":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/shim.js"},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/index.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/index.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/is-implemented.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/is-implemented.js","source":"'use strict';\n\nvar str = 'razdwatrzy';\n\nmodule.exports = function () {\n\tif (typeof str.contains !== 'function') return false;\n\treturn ((str.contains('dwa') === true) && (str.contains('foo') === false));\n};\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/is-implemented.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/is-implemented.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/shim.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/shim.js","source":"'use strict';\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/shim.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/shim.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/polyfill.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/polyfill.js","source":"'use strict';\n\nvar d              = require('d')\n  , validateSymbol = require('./validate-symbol')\n\n  , create = Object.create, defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty, objPrototype = Object.prototype\n  , Symbol, HiddenSymbol, globalSymbols = create(null);\n\nvar generateName = (function () {\n\tvar created = create(null);\n\treturn function (desc) {\n\t\tvar postfix = 0, name;\n\t\twhile (created[desc + (postfix || '')]) ++postfix;\n\t\tdesc += (postfix || '');\n\t\tcreated[desc] = true;\n\t\tname = '@@' + desc;\n\t\tdefineProperty(objPrototype, name, d.gs(null, function (value) {\n\t\t\tdefineProperty(this, name, d(value));\n\t\t}));\n\t\treturn name;\n\t};\n}());\n\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');\n\treturn Symbol(description);\n};\nmodule.exports = Symbol = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = (description === undefined ? '' : String(description));\n\treturn defineProperties(symbol, {\n\t\t__description__: d('', description),\n\t\t__name__: d('', generateName(description))\n\t});\n};\ndefineProperties(Symbol, {\n\tfor: d(function (key) {\n\t\tif (globalSymbols[key]) return globalSymbols[key];\n\t\treturn (globalSymbols[key] = Symbol(String(key)));\n\t}),\n\tkeyFor: d(function (s) {\n\t\tvar key;\n\t\tvalidateSymbol(s);\n\t\tfor (key in globalSymbols) if (globalSymbols[key] === s) return key;\n\t}),\n\thasInstance: d('', Symbol('hasInstance')),\n\tisConcatSpreadable: d('', Symbol('isConcatSpreadable')),\n\titerator: d('', Symbol('iterator')),\n\tmatch: d('', Symbol('match')),\n\treplace: d('', Symbol('replace')),\n\tsearch: d('', Symbol('search')),\n\tspecies: d('', Symbol('species')),\n\tsplit: d('', Symbol('split')),\n\ttoPrimitive: d('', Symbol('toPrimitive')),\n\ttoStringTag: d('', Symbol('toStringTag')),\n\tunscopables: d('', Symbol('unscopables'))\n});\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(Symbol),\n\ttoString: d('', function () { return this.__name__; })\n});\n\ndefineProperties(Symbol.prototype, {\n\ttoString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(Symbol.prototype, Symbol.toPrimitive, d('',\n\tfunction () { return validateSymbol(this); }));\ndefineProperty(Symbol.prototype, Symbol.toStringTag, d('c', 'Symbol'));\n\ndefineProperty(HiddenSymbol.prototype, Symbol.toPrimitive,\n\td('c', Symbol.prototype[Symbol.toPrimitive]));\ndefineProperty(HiddenSymbol.prototype, Symbol.toStringTag,\n\td('c', Symbol.prototype[Symbol.toStringTag]));\n","deps":{"./validate-symbol":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/validate-symbol.js","d":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/d/index.js"},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/polyfill.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/polyfill.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/validate-symbol.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/validate-symbol.js","source":"'use strict';\n\nvar isSymbol = require('./is-symbol');\n\nmodule.exports = function (value) {\n\tif (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n\treturn value;\n};\n","deps":{"./is-symbol":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/is-symbol.js"},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/validate-symbol.js","sourceRoot":"file://localhost","sourceFile":"node_modules/es6-symbol/validate-symbol.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/inherits/inherits_browser.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/inherits/inherits_browser.js","source":"if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/inherits/inherits_browser.js","sourceRoot":"file://localhost","sourceFile":"node_modules/inherits/inherits_browser.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/is-buffer/index.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/is-buffer/index.js","source":"/**\n * Determine if an object is Buffer\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n * `npm install is-buffer`\n */\n\nmodule.exports = function (obj) {\n  return !!(\n    obj != null &&\n    obj.constructor &&\n    typeof obj.constructor.isBuffer === 'function' &&\n    obj.constructor.isBuffer(obj)\n  )\n}\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/is-buffer/index.js","sourceRoot":"file://localhost","sourceFile":"node_modules/is-buffer/index.js"},"/Users/dubroy/dev/cdg/ohm/node_modules/util-extend/extend.js":{"id":"/Users/dubroy/dev/cdg/ohm/node_modules/util-extend/extend.js","source":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = extend;\nfunction extend(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || typeof add !== 'object') return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n}\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/node_modules/util-extend/extend.js","sourceRoot":"file://localhost","sourceFile":"node_modules/util-extend/extend.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-toExpected.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toExpected.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.toExpected = common.abstract;\n\npexprs.anything.toExpected = function(ruleDict) {\n  return 'any object';\n};\n\npexprs.end.toExpected = function(ruleDict) {\n  return 'end of input';\n};\n\npexprs.Prim.prototype.toExpected = function(ruleDict) {\n  return JSON.stringify(this.obj);\n};\n\npexprs.Range.prototype.toExpected = function(ruleDict) {\n  // TODO: come up with something better\n  return JSON.stringify(this.from) + '..' + JSON.stringify(this.to);\n};\n\npexprs.Not.prototype.toExpected = function(ruleDict) {\n  if (this.expr === pexprs.anything) {\n    return 'nothing';\n  } else {\n    return 'not ' + this.expr.toExpected(ruleDict);\n  }\n};\n\n// TODO: think about Arr, Str, and Obj\n\npexprs.Apply.prototype.toExpected = function(ruleDict) {\n  var description = ruleDict[this.ruleName].description;\n  if (description) {\n    return description;\n  } else {\n    var article = (/^[aeiouAEIOU]/.test(this.ruleName) ? 'an' : 'a');\n    return article + ' ' + this.ruleName;\n  }\n};\n\npexprs.UnicodeChar.prototype.toExpected = function(ruleDict) {\n  return 'a ' + this.toDisplayString();\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toExpected.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-toExpected.js"},"/Users/dubroy/dev/cdg/ohm/src/Builder.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/Builder.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar GrammarDecl = require('./GrammarDecl');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction Builder() {}\n\nBuilder.prototype = {\n  newGrammar: function(name) {\n    return new GrammarDecl(name);\n  },\n\n  prim: function(x) {\n    return new pexprs.Prim(x);\n  },\n\n  range: function(from, to) {\n    return new pexprs.Range(from, to);\n  },\n\n  param: function(index) {\n    return new pexprs.Param(index);\n  },\n\n  alt: function(/* term1, term1, ... */) {\n    var terms = [];\n    for (var idx = 0; idx < arguments.length; idx++) {\n      var arg = arguments[idx];\n      if (arg instanceof pexprs.Alt) {\n        terms = terms.concat(arg.terms);\n      } else {\n        terms.push(arg);\n      }\n    }\n    return terms.length === 1 ? terms[0] : new pexprs.Alt(terms);\n  },\n\n  seq: function(/* factor1, factor2, ... */) {\n    var factors = [];\n    for (var idx = 0; idx < arguments.length; idx++) {\n      var arg = arguments[idx];\n      if (arg instanceof pexprs.Seq) {\n        factors = factors.concat(arg.factors);\n      } else {\n        factors.push(arg);\n      }\n    }\n    return factors.length === 1 ? factors[0] : new pexprs.Seq(factors);\n  },\n\n  star: function(expr) {\n    return new pexprs.Star(expr);\n  },\n\n  plus: function(expr) {\n    return new pexprs.Plus(expr);\n  },\n\n  opt: function(expr) {\n    return new pexprs.Opt(expr);\n  },\n\n  not: function(expr) {\n    return new pexprs.Not(expr);\n  },\n\n  la: function(expr) {\n    return new pexprs.Lookahead(expr);\n  },\n\n  lex: function(expr) {\n    return new pexprs.Lex(expr);\n  },\n\n  arr: function(expr) {\n    return new pexprs.Arr(expr);\n  },\n\n  str: function(expr) {\n    return new pexprs.Str(expr);\n  },\n\n  obj: function(properties, isLenient) {\n    return new pexprs.Obj(properties, !!isLenient);\n  },\n\n  app: function(ruleName, optParams) {\n    return new pexprs.Apply(ruleName, optParams);\n  }\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = Builder;\n","deps":{"./GrammarDecl":"/Users/dubroy/dev/cdg/ohm/src/GrammarDecl.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/Builder.js","sourceRoot":"file://localhost","sourceFile":"src/Builder.js"},"/Users/dubroy/dev/cdg/ohm/src/Failure.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/Failure.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n/*\n  `Failure`s represent expressions that weren't matched while parsing. They are used to generate\n  error messages automatically. The interface of `Failure`s includes the collowing methods:\n\n  - getText() : String\n  - getType() : String  (one of {\"description\", \"string\", \"code\"})\n  - isDescription() : bool\n  - isStringTerminal() : bool\n  - isCode() : bool\n  - isFluffy() : bool\n  - makeFluffy() : void\n  - subsumes(Failure) : bool\n*/\n\nfunction isValidType(type) {\n  return type === 'description' || type === 'string' || type === 'code';\n}\n\nfunction Failure(text, type) {\n  if (!isValidType(type)) {\n    throw new Error('invalid Failure type: ' + type);\n  }\n\n  this.text = text;\n  this.type = type;\n  this.fluffy = false;\n}\n\nFailure.prototype.getText = function() {\n  return this.text;\n};\n\nFailure.prototype.getType = function() {\n  return this.type;\n};\n\nFailure.prototype.isDescription = function() {\n  return this.type === 'description';\n};\n\nFailure.prototype.isStringTerminal = function() {\n  return this.type === 'string';\n};\n\nFailure.prototype.isCode = function() {\n  return this.type === 'code';\n};\n\nFailure.prototype.isFluffy = function() {\n  return this.fluffy;\n};\n\nFailure.prototype.makeFluffy = function() {\n  this.fluffy = true;\n};\n\nFailure.prototype.subsumes = function(that) {\n  return this.getText() === that.getText() &&\n      this.type === that.type &&\n      (!this.isFluffy() || this.isFluffy() && that.isFluffy());\n};\n\nFailure.prototype.toString = function() {\n  return this.type === 'string' ?\n    JSON.stringify(this.getText()) :\n    this.getText();\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = Failure;\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/src/Failure.js","sourceRoot":"file://localhost","sourceFile":"src/Failure.js"},"/Users/dubroy/dev/cdg/ohm/src/GrammarDecl.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/GrammarDecl.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar Grammar = require('./Grammar');\nvar common = require('./common');\nvar errors = require('./errors');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Private Stuff\n// --------------------------------------------------------------------\n\n// Constructors\n\nfunction GrammarDecl(name) {\n  this.name = name;\n}\n\n// Helpers\n\nGrammarDecl.prototype.ensureSuperGrammar = function() {\n  if (!this.superGrammar) {\n    this.withSuperGrammar(\n        // TODO: The conditional expression below is an ugly hack. It's kind of ok because\n        // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,\n        // we should try to find a better way to do this.\n        this.name === 'BuiltInRules' ?\n            Grammar.ProtoBuiltInRules :\n            Grammar.BuiltInRules);\n  }\n  return this.superGrammar;\n};\n\nGrammarDecl.prototype.installOverriddenOrExtendedRule = function(name, formals, body) {\n  var duplicateParameterNames = common.getDuplicates(formals);\n  if (duplicateParameterNames.length > 0) {\n    throw errors.duplicateParameterNames(name, duplicateParameterNames, body);\n  }\n  var expectedFormals = this.ensureSuperGrammar().ruleFormals[name];\n  var expectedNumFormals = expectedFormals ? expectedFormals.length : 0;\n  if (formals.length !== expectedNumFormals) {\n    throw errors.wrongNumberOfParameters(name, expectedNumFormals, formals.length, body);\n  }\n  return this.install(name, formals, body);\n};\n\nGrammarDecl.prototype.install = function(name, formals, body, optDescription) {\n  body = body.introduceParams(formals);\n  this.ruleFormals[name] = formals;\n  if (optDescription) {\n    this.ruleDescriptions[name] = optDescription;\n  }\n  this.ruleBodies[name] = body;\n  return this;\n};\n\n// Stuff that you should only do once\n\nGrammarDecl.prototype.withSuperGrammar = function(superGrammar) {\n  if (this.superGrammar) {\n    throw new Error('the super grammar of a GrammarDecl cannot be set more than once');\n  }\n  this.superGrammar = superGrammar;\n  this.ruleBodies = Object.create(superGrammar.ruleBodies);\n  this.ruleFormals = Object.create(superGrammar.ruleFormals);\n  this.ruleDescriptions = Object.create(superGrammar.ruleDescriptions);\n\n  // Grammars with an explicit supergrammar inherit a default start rule.\n  if (!superGrammar.isBuiltIn()) {\n    this.defaultStartRule = superGrammar.defaultStartRule;\n  }\n  return this;\n};\n\nGrammarDecl.prototype.withDefaultStartRule = function(ruleName) {\n  this.defaultStartRule = ruleName;\n  return this;\n};\n\n// Creates a Grammar instance, and if it passes the sanity checks, returns it.\nGrammarDecl.prototype.build = function() {\n  var grammar = new Grammar(\n      this.name,\n      this.ensureSuperGrammar(),\n      this.ruleBodies,\n      this.ruleFormals,\n      this.ruleDescriptions,\n      this.defaultStartRule);\n  // TODO: change the pexpr.prototype.assert... methods to make them add\n  // exceptions to an array that's provided as an arg. Then we'll be able to\n  // show more than one error of the same type at a time.\n  // TODO: include the offending pexpr in the errors, that way we can show\n  // the part of the source that caused it.\n  var grammarErrors = [];\n  var grammarHasInvalidApplications = false;\n  Object.keys(grammar.ruleBodies).forEach(function(ruleName) {\n    var body = grammar.ruleBodies[ruleName];\n    try {\n      body.assertChoicesHaveUniformArity(ruleName);\n    } catch (e) {\n      grammarErrors.push(e);\n    }\n    try {\n      body.assertAllApplicationsAreValid(ruleName, grammar);\n    } catch (e) {\n      grammarErrors.push(e);\n      grammarHasInvalidApplications = true;\n    }\n  });\n  if (!grammarHasInvalidApplications) {\n    // The following check can only be done if the grammar has no invalid applications.\n    Object.keys(grammar.ruleBodies).forEach(function(ruleName) {\n      var body = grammar.ruleBodies[ruleName];\n      try {\n        body.assertIteratedExprsAreNotNullable(grammar, ruleName);\n      } catch (e) {\n        grammarErrors.push(e);\n      }\n    });\n  }\n  if (grammarErrors.length > 0) {\n    errors.throwErrors(grammarErrors);\n  }\n  return grammar;\n};\n\n// Rule declarations\n\nGrammarDecl.prototype.define = function(name, formals, body, optDescr) {\n  this.ensureSuperGrammar();\n  if (this.superGrammar.ruleBodies[name]) {\n    throw errors.duplicateRuleDeclaration(name, this.name, this.superGrammar.name, body);\n  } else if (this.ruleBodies[name]) {\n    throw errors.duplicateRuleDeclaration(name, this.name, this.name, body);\n  }\n  var duplicateParameterNames = common.getDuplicates(formals);\n  if (duplicateParameterNames.length > 0) {\n    throw errors.duplicateParameterNames(name, duplicateParameterNames, body);\n  }\n  return this.install(name, formals, body, optDescr);\n};\n\nGrammarDecl.prototype.override = function(name, formals, body) {\n  var baseRule = this.ensureSuperGrammar().ruleBodies[name];\n  if (!baseRule) {\n    throw errors.cannotOverrideUndeclaredRule(name, this.superGrammar.name, body);\n  }\n  this.installOverriddenOrExtendedRule(name, formals, body);\n  return this;\n};\n\nGrammarDecl.prototype.extend = function(name, formals, body) {\n  var baseRule = this.ensureSuperGrammar().ruleBodies[name];\n  if (!baseRule) {\n    throw errors.cannotExtendUndeclaredRule(name, this.superGrammar.name, body);\n  }\n  this.installOverriddenOrExtendedRule(\n      name, formals, new pexprs.Extend(this.superGrammar, name, body));\n  return this;\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = GrammarDecl;\n","deps":{"./Grammar":"/Users/dubroy/dev/cdg/ohm/src/Grammar.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js","./errors":"/Users/dubroy/dev/cdg/ohm/src/errors.js","./common":"/Users/dubroy/dev/cdg/ohm/src/common.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/GrammarDecl.js","sourceRoot":"file://localhost","sourceFile":"src/GrammarDecl.js"},"/Users/dubroy/dev/cdg/ohm/src/InputStream.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/InputStream.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar Interval = require('./Interval');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction InputStream() {\n  throw new Error('InputStream cannot be instantiated -- it\\'s abstract');\n}\n\nInputStream.newFor = function(obj) {\n  if (typeof obj === 'string') {\n    return new StringInputStream(obj);\n  } else if (Array.isArray(obj)) {\n    return new ListInputStream(obj);\n  } else if (obj instanceof InputStream) {\n    return obj;\n  } else {\n    throw new Error('cannot make input stream for ' + obj);\n  }\n};\n\nInputStream.prototype = {\n  init: function(source) {\n    this.source = source;\n    this.pos = 0;\n    this.posInfos = [];\n  },\n\n  atEnd: function() {\n    return this.pos === this.source.length;\n  },\n\n  next: function() {\n    if (this.atEnd()) {\n      return common.fail;\n    } else {\n      return this.source[this.pos++];\n    }\n  },\n\n  matchExactly: function(x) {\n    return this.next() === x ? true : common.fail;\n  },\n\n  sourceSlice: function(startIdx, endIdx) {\n    return this.source.slice(startIdx, endIdx);\n  },\n\n  interval: function(startIdx, optEndIdx) {\n    return new Interval(this, startIdx, optEndIdx ? optEndIdx : this.pos);\n  }\n};\n\nfunction StringInputStream(source) {\n  this.init(source);\n}\n\nStringInputStream.prototype = Object.create(InputStream.prototype, {\n  matchString: {\n    value: function(s) {\n      for (var idx = 0; idx < s.length; idx++) {\n        if (this.matchExactly(s[idx]) === common.fail) {\n          return common.fail;\n        }\n      }\n      return true;\n    }\n  }\n});\n\nfunction ListInputStream(source) {\n  this.init(source);\n}\n\nListInputStream.prototype = Object.create(InputStream.prototype, {\n  matchString: {\n    value: function(s) {\n      return this.matchExactly(s);\n    }\n  }\n});\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = InputStream;\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./Interval":"/Users/dubroy/dev/cdg/ohm/src/Interval.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/InputStream.js","sourceRoot":"file://localhost","sourceFile":"src/InputStream.js"},"/Users/dubroy/dev/cdg/ohm/src/Interval.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/Interval.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar errors = require('./errors');\nvar util = require('./util');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction Interval(inputStream, startIdx, endIdx) {\n  this.inputStream = inputStream;\n  this.startIdx = startIdx;\n  this.endIdx = endIdx;\n}\n\nInterval.coverage = function(/* interval1, interval2, ... */) {\n  var inputStream = arguments[0].inputStream;\n  var startIdx = arguments[0].startIdx;\n  var endIdx = arguments[0].endIdx;\n  for (var idx = 1; idx < arguments.length; idx++) {\n    var interval = arguments[idx];\n    if (interval.inputStream !== inputStream) {\n      throw errors.intervalSourcesDontMatch();\n    } else {\n      startIdx = Math.min(startIdx, arguments[idx].startIdx);\n      endIdx = Math.max(endIdx, arguments[idx].endIdx);\n    }\n  }\n  return new Interval(inputStream, startIdx, endIdx);\n};\n\nInterval.prototype = {\n  coverageWith: function(/* interval1, interval2, ... */) {\n    var intervals = Array.prototype.slice.call(arguments);\n    intervals.push(this);\n    return Interval.coverage.apply(undefined, intervals);\n  },\n\n  collapsedLeft: function() {\n    return new Interval(this.inputStream, this.startIdx, this.startIdx);\n  },\n\n  collapsedRight: function() {\n    return new Interval(this.inputStream, this.endIdx, this.endIdx);\n  },\n\n  getLineAndColumnMessage: function() {\n    var range = [this.startIdx, this.endIdx];\n    return util.getLineAndColumnMessage(this.inputStream.source, this.startIdx, range);\n  },\n\n  // Returns a new Interval which contains the same contents as this one,\n  // but with whitespace trimmed from both ends. (This only makes sense when\n  // the input stream is a string.)\n  trimmed: function() {\n    var contents = this.contents;\n    var startIdx = this.startIdx + contents.match(/^\\s*/)[0].length;\n    var endIdx = this.endIdx - contents.match(/\\s*$/)[0].length;\n    return new Interval(this.inputStream, startIdx, endIdx);\n  }\n};\n\nObject.defineProperties(Interval.prototype, {\n  contents: {\n    get: function() {\n      if (this._contents === undefined) {\n        this._contents = this.inputStream.sourceSlice(this.startIdx, this.endIdx);\n      }\n      return this._contents;\n    },\n    enumerable: true\n  }\n});\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = Interval;\n\n","deps":{"./errors":"/Users/dubroy/dev/cdg/ohm/src/errors.js","./util":"/Users/dubroy/dev/cdg/ohm/src/util.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/Interval.js","sourceRoot":"file://localhost","sourceFile":"src/Interval.js"},"/Users/dubroy/dev/cdg/ohm/src/MatchResult.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/MatchResult.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar inherits = require('inherits');\n\nvar common = require('./common');\nvar util = require('./util');\nvar Interval = require('./Interval');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Create a short error message for an error that occurred during matching.\nfunction getShortMatchErrorMessage(pos, source, detail) {\n  var errorInfo = util.getLineAndColumn(source, pos);\n  return 'Line ' + errorInfo.lineNum + ', col ' + errorInfo.colNum + ': ' + detail;\n}\n\n// ----------------- MatchFailure -----------------\n\nfunction MatchResult(state) {\n  this.state = state;\n  this._cst = state.bindings[0];\n}\n\nMatchResult.newFor = function(state) {\n  var succeeded = state.bindings.length === 1;\n  return succeeded ? new MatchResult(state) : new MatchFailure(state);\n};\n\nMatchResult.prototype.failed = function() {\n  return false;\n};\n\nMatchResult.prototype.succeeded = function() {\n  return !this.failed();\n};\n\n// ----------------- MatchFailure -----------------\n\nfunction MatchFailure(state) {\n  this.state = state;\n  common.defineLazyProperty(this, '_failures', function() {\n    return this.state.getFailures();\n  });\n  common.defineLazyProperty(this, 'message', function() {\n    var source = this.state.inputStream.source;\n    if (typeof source !== 'string') {\n      return 'match failed at position ' + this.getRightmostFailurePosition();\n    }\n\n    var detail = 'Expected ' + this.getExpectedText();\n    return util.getLineAndColumnMessage(source, this.getRightmostFailurePosition()) + detail;\n  });\n  common.defineLazyProperty(this, 'shortMessage', function() {\n    if (typeof this.state.inputStream.source !== 'string') {\n      return 'match failed at position ' + this.getRightmostFailurePosition();\n    }\n    var detail = 'expected ' + this.getExpectedText();\n    return getShortMatchErrorMessage(\n        this.getRightmostFailurePosition(),\n        this.state.inputStream.source,\n        detail);\n  });\n}\ninherits(MatchFailure, MatchResult);\n\nMatchFailure.prototype.toString = function() {\n  return '[MatchFailure at position ' + this.getRightmostFailurePosition() + ']';\n};\n\nMatchFailure.prototype.failed = function() {\n  return true;\n};\n\nMatchFailure.prototype.getRightmostFailurePosition = function() {\n  return this.state.getRightmostFailurePosition();\n};\n\nMatchFailure.prototype.getRightmostFailures = function() {\n  return this._failures;\n};\n\n// Return a string summarizing the expected contents of the input stream when\n// the match failure occurred.\nMatchFailure.prototype.getExpectedText = function() {\n  var sb = new common.StringBuffer();\n  var failures = this.getRightmostFailures();\n\n  // Filter out the fluffy failures to make the default error messages more useful\n  failures = failures.filter(function(failure) {\n    return !failure.isFluffy();\n  });\n\n  for (var idx = 0; idx < failures.length; idx++) {\n    if (idx > 0) {\n      if (idx === failures.length - 1) {\n        sb.append((failures.length > 2 ? ', or ' : ' or '));\n      } else {\n        sb.append(', ');\n      }\n    }\n    sb.append(failures[idx].toString());\n  }\n  return sb.contents();\n};\n\nMatchFailure.prototype.getInterval = function() {\n  var pos = this.state.getRightmostFailurePosition();\n  return new Interval(this.state.inputStream, pos, pos);\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = MatchResult;\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./util":"/Users/dubroy/dev/cdg/ohm/src/util.js","./Interval":"/Users/dubroy/dev/cdg/ohm/src/Interval.js","inherits":"/Users/dubroy/dev/cdg/ohm/node_modules/inherits/inherits_browser.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/MatchResult.js","sourceRoot":"file://localhost","sourceFile":"src/MatchResult.js"},"/Users/dubroy/dev/cdg/ohm/src/Namespace.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/Namespace.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar extend = require('util-extend');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction Namespace() {\n}\nNamespace.prototype = Object.create(null);\n\nNamespace.asNamespace = function(objOrNamespace) {\n  if (objOrNamespace instanceof Namespace) {\n    return objOrNamespace;\n  }\n  return Namespace.createNamespace(objOrNamespace);\n};\n\n// Create a new namespace. If `optProps` is specified, all of its properties\n// will be copied to the new namespace.\nNamespace.createNamespace = function(optProps) {\n  return Namespace.extend(Namespace.prototype, optProps);\n};\n\n// Create a new namespace which extends another namespace. If `optProps` is\n// specified, all of its properties will be copied to the new namespace.\nNamespace.extend = function(namespace, optProps) {\n  if (namespace !== Namespace.prototype && !(namespace instanceof Namespace)) {\n    throw new TypeError('not a Namespace object: ' + namespace);\n  }\n  var ns = Object.create(namespace, {\n    constructor: {\n      value: Namespace,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  return extend(ns, optProps);\n};\n\n// TODO: Should this be a regular method?\nNamespace.toString = function(ns) {\n  return Object.prototype.toString.call(ns);\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = Namespace;\n","deps":{"util-extend":"/Users/dubroy/dev/cdg/ohm/node_modules/util-extend/extend.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/Namespace.js","sourceRoot":"file://localhost","sourceFile":"src/Namespace.js"},"/Users/dubroy/dev/cdg/ohm/src/PosInfo.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/PosInfo.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction PosInfo(state) {\n  this.state = state;\n  this.applicationMemoKeyStack = [];  // a stack of \"memo keys\" of the active applications\n  this.memo = {};\n  this.currentLeftRecursion = undefined;\n}\n\nPosInfo.prototype = {\n  isActive: function(application) {\n    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;\n  },\n\n  enter: function(application) {\n    this.state.enter(application);\n    this.applicationMemoKeyStack.push(application.toMemoKey());\n  },\n\n  exit: function() {\n    this.state.exit();\n    this.applicationMemoKeyStack.pop();\n  },\n\n  startLeftRecursion: function(headApplication, memoRec) {\n    memoRec.isLeftRecursion = true;\n    memoRec.headApplication = headApplication;\n    memoRec.nextLeftRecursion = this.currentLeftRecursion;\n    this.currentLeftRecursion = memoRec;\n\n    var applicationMemoKeyStack = this.applicationMemoKeyStack;\n    var indexOfFirstInvolvedRule = applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;\n    var involvedApplicationMemoKeys = applicationMemoKeyStack.slice(indexOfFirstInvolvedRule);\n\n    memoRec.isInvolved = function(applicationMemoKey) {\n      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;\n    };\n\n    memoRec.updateInvolvedApplicationMemoKeys = function() {\n      for (var idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {\n        var applicationMemoKey = applicationMemoKeyStack[idx];\n        if (!this.isInvolved(applicationMemoKey)) {\n          involvedApplicationMemoKeys.push(applicationMemoKey);\n        }\n      }\n    };\n  },\n\n  endLeftRecursion: function() {\n    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;\n  },\n\n  // Note: this method doesn't get called for the \"head\" of a left recursion -- for LR heads,\n  // the memoized result (which starts out being a failure) is always used.\n  shouldUseMemoizedResult: function(memoRec) {\n    if (!memoRec.isLeftRecursion) {\n      return true;\n    }\n    var applicationMemoKeyStack = this.applicationMemoKeyStack;\n    for (var idx = 0; idx < applicationMemoKeyStack.length; idx++) {\n      var applicationMemoKey = applicationMemoKeyStack[idx];\n      if (memoRec.isInvolved(applicationMemoKey)) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = PosInfo;\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/src/PosInfo.js","sourceRoot":"file://localhost","sourceFile":"src/PosInfo.js"},"/Users/dubroy/dev/cdg/ohm/src/State.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/State.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar PosInfo = require('./PosInfo');\nvar Trace = require('./Trace');\nvar fsets = require('./fsets');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nvar RM_RIGHTMOST_FAILURE_POSITION = 0;\nvar RM_RIGHTMOST_FAILURES = 1;\n\nvar applySpaces_ = new pexprs.Apply('spaces_');\n\nfunction State(grammar, inputStream, startRule, tracingEnabled) {\n  this.grammar = grammar;\n  this.origInputStream = inputStream;\n  this.startRule = startRule;\n  this.tracingEnabled = tracingEnabled;\n  this.init(RM_RIGHTMOST_FAILURE_POSITION);\n}\n\nState.prototype = {\n  init: function(recordingMode) {\n    this.bindings = [];\n\n    this.inputStreamStack = [];\n    this.posInfosStack = [];\n    this.pushInputStream(this.origInputStream);\n\n    this.applicationStack = [];\n    this.inLexifiedContextStack = [false];\n\n    this.recordingMode = recordingMode;\n    if (recordingMode === RM_RIGHTMOST_FAILURE_POSITION) {\n      this.rightmostFailurePosition = -1;\n    } else if (recordingMode === RM_RIGHTMOST_FAILURES) {\n      this.rightmostFailures = fsets.empty;\n\n      // We always run in *rightmost failure position* recording mode before running in\n      // *rightmost failures* recording mode. And since the traces generated by each of\n      // these passes would be identical, there's no need to record it now if we have\n      // already recorded it in the first pass.\n      this.tracingEnabled = false;\n    } else {\n      throw new Error('invalid recording mode: ' + recordingMode);\n    }\n\n    if (this.isTracing()) {\n      this.trace = [];\n    }\n  },\n\n  enter: function(app) {\n    this.applicationStack.push(app);\n    this.inLexifiedContextStack.push(false);\n  },\n\n  exit: function() {\n    this.applicationStack.pop();\n    this.inLexifiedContextStack.pop();\n  },\n\n  enterLexifiedContext: function() {\n    this.inLexifiedContextStack.push(true);\n  },\n\n  exitLexifiedContext: function() {\n    this.inLexifiedContextStack.pop();\n  },\n\n  currentApplication: function() {\n    return this.applicationStack[this.applicationStack.length - 1];\n  },\n\n  inSyntacticRule: function() {\n    if (typeof this.inputStream.source !== 'string') {\n      return false;\n    }\n    var currentApplication = this.currentApplication();\n    return currentApplication && currentApplication.isSyntactic();\n  },\n\n  inSyntacticContext: function() {\n    return this.inSyntacticRule() && !this.inLexifiedContext();\n  },\n\n  inLexifiedContext: function() {\n    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];\n  },\n\n  skipSpaces: function() {\n    var origFailuresInfo = this.getFailuresInfo();\n    this.eval(applySpaces_);\n    this.bindings.pop();\n    this.restoreFailuresInfo(origFailuresInfo);\n    return this.inputStream.pos;\n  },\n\n  skipSpacesIfInSyntacticContext: function() {\n    return this.inSyntacticContext() ?\n        this.skipSpaces() :\n        this.inputStream.pos;\n  },\n\n  truncateBindings: function(newLength) {\n    // TODO: is this really faster than setting the `length` property?\n    while (this.bindings.length > newLength) {\n      this.bindings.pop();\n    }\n  },\n\n  pushInputStream: function(inputStream) {\n    this.inputStreamStack.push(this.inputStream);\n    this.posInfosStack.push(this.posInfos);\n    this.inputStream = inputStream;\n    this.posInfos = [];\n  },\n\n  popInputStream: function() {\n    this.inputStream = this.inputStreamStack.pop();\n    this.posInfos = this.posInfosStack.pop();\n  },\n\n  getCurrentPosInfo: function() {\n    return this.getPosInfo(this.inputStream.pos);\n  },\n\n  getPosInfo: function(pos) {\n    var posInfo = this.posInfos[pos];\n    return posInfo || (this.posInfos[pos] = new PosInfo(this));\n  },\n\n  processFailure: function(pos, expr) {\n    if (this.recordingMode === RM_RIGHTMOST_FAILURE_POSITION) {\n      if (pos > this.rightmostFailurePosition) {\n        this.rightmostFailurePosition = pos;\n      }\n    } else /* if (this.recordingMode === RM_RIGHTMOST_FAILURES) */ {\n      // We're only interested in failures at the rightmost failure position that haven't\n      // already been recorded.\n      if (pos === this.rightmostFailurePosition && !this.rightmostFailures.includes(expr)) {\n        this.rightmostFailures = new fsets.Singleton(expr).union(this.rightmostFailures);\n      }\n    }\n  },\n\n  getRightmostFailurePosition: function() {\n    return this.rightmostFailurePosition;\n  },\n\n  getFailures: function() {\n    if (!this.rightmostFailures) {\n      // Rewind, then try to match the input again, recording failures.\n      this.init(RM_RIGHTMOST_FAILURES);\n      this.eval(new pexprs.Apply(this.startRule));\n    }\n\n    return this.rightmostFailures.toFailuresArray(this.grammar);\n  },\n\n  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.\n  getMemoizedTraceEntry: function(pos, expr) {\n    var posInfo = this.posInfos[pos];\n    if (posInfo && expr.ruleName) {\n      var memoRec = posInfo.memo[expr.toMemoKey()];\n      if (memoRec) {\n        return memoRec.traceEntry;\n      }\n    }\n    return null;\n  },\n\n  // Returns the memoized trace entry for `expr` at `pos`, if one exists, or a new trace entry\n  // whose children is the currently active trace array.\n  getTraceEntry: function(pos, expr, result) {\n    var entry = this.getMemoizedTraceEntry(pos, expr);\n    if (!entry) {\n      entry = new Trace(this.inputStream, pos, expr, result, this.trace);\n    }\n    return entry;\n  },\n\n  isTracing: function() {\n    return this.tracingEnabled;\n  },\n\n  useMemoizedResult: function(memoRec) {\n    if (this.isTracing()) {\n      this.trace.push(memoRec.traceEntry);\n    }\n    if (this.recordingMode === RM_RIGHTMOST_FAILURES) {\n      this.rightmostFailures = this.rightmostFailures.union(memoRec.failuresAtRightmostPosition);\n    }\n\n    if (memoRec.value) {\n      this.inputStream.pos = memoRec.pos;\n      this.bindings.push(memoRec.value);\n      return true;\n    }\n    return false;\n  },\n\n  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`\n  // will have `expr.getArity()` more elements than before, and the input stream's position may\n  // have increased. On failure, `bindings` and position will be unchanged.\n  eval: function(expr) {\n    var inputStream = this.inputStream;\n    var origPos = inputStream.pos;\n    var origNumBindings = this.bindings.length;\n\n    if (this.recordingMode === RM_RIGHTMOST_FAILURES) {\n      var origFailures = this.rightmostFailures;\n      this.rightmostFailures = fsets.empty;\n    }\n\n    if (this.isTracing()) {\n      var origTrace = this.trace;\n      this.trace = [];\n    }\n\n    // Do the actual evaluation.\n    var ans = expr.eval(this);\n\n    if (this.isTracing()) {\n      var traceEntry = this.getTraceEntry(origPos, expr, ans);\n      origTrace.push(traceEntry);\n      this.trace = origTrace;\n    }\n\n    if (ans) {\n      if (this.recordingMode === RM_RIGHTMOST_FAILURES &&\n          inputStream.pos === this.rightmostFailurePosition) {\n        this.rightmostFailures = this.rightmostFailures.asFluffy();\n      }\n    } else {\n      // Reset the position and the bindings.\n      inputStream.pos = origPos;\n      this.truncateBindings(origNumBindings);\n    }\n\n    if (this.recordingMode === RM_RIGHTMOST_FAILURES) {\n      this.rightmostFailures = origFailures.union(this.rightmostFailures);\n    }\n\n    return ans;\n  },\n\n  getFailuresInfo: function() {\n    if (this.recordingMode === RM_RIGHTMOST_FAILURE_POSITION) {\n      return this.rightmostFailurePosition;\n    } else /* if (this.recordingMode === RM_RIGHTMOST_FAILURES) */ {\n      return this.rightmostFailures;\n    }\n  },\n\n  restoreFailuresInfo: function(failuresInfo) {\n    if (this.recordingMode === RM_RIGHTMOST_FAILURE_POSITION) {\n      this.rightmostFailurePosition = failuresInfo;\n    } else /* if (this.recordingMode === RM_RIGHTMOST_FAILURES) */ {\n      this.rightmostFailures = failuresInfo;\n    }\n  },\n\n  applySpaces_: applySpaces_\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = State;\n","deps":{"./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js","./PosInfo":"/Users/dubroy/dev/cdg/ohm/src/PosInfo.js","./fsets":"/Users/dubroy/dev/cdg/ohm/src/fsets.js","./Trace":"/Users/dubroy/dev/cdg/ohm/src/Trace.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/State.js","sourceRoot":"file://localhost","sourceFile":"src/State.js"},"/Users/dubroy/dev/cdg/ohm/src/Trace.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/Trace.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar Interval = require('./Interval');\nvar common = require('./common');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Unicode characters that are used in the `toString` output.\nvar BALLOT_X = '\\u2717';\nvar CHECK_MARK = '\\u2713';\nvar DOT_OPERATOR = '\\u22C5';\nvar RIGHTWARDS_DOUBLE_ARROW = '\\u21D2';\nvar SYMBOL_FOR_HORIZONTAL_TABULATION = '\\u2409';\nvar SYMBOL_FOR_LINE_FEED = '\\u240A';\nvar SYMBOL_FOR_CARRIAGE_RETURN = '\\u240D';\n\nfunction linkLeftRecursiveChildren(children) {\n  for (var i = 0; i < children.length; ++i) {\n    var child = children[i];\n    var nextChild = children[i + 1];\n\n    if (nextChild && child.expr === nextChild.expr) {\n      child.replacedBy = nextChild;\n    }\n  }\n}\n\nfunction spaces(n) {\n  return common.repeat(' ', n).join('');\n}\n\n// Return a string representation of a portion of `inputStream` at offset `pos`.\n// The result will contain exactly `len` characters.\nfunction getInputExcerpt(inputStream, pos, len) {\n  var excerpt = asEscapedString(inputStream.sourceSlice(pos, pos + len));\n\n  // Pad the output if necessary.\n  if (excerpt.length < len) {\n    return excerpt + common.repeat(' ', len - excerpt.length).join('');\n  }\n  return excerpt;\n}\n\nfunction asEscapedString(obj) {\n  if (typeof obj === 'string') {\n    // Replace non-printable characters with visible symbols.\n    return obj\n        .replace(/ /g, DOT_OPERATOR)\n        .replace(/\\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION)\n        .replace(/\\n/g, SYMBOL_FOR_LINE_FEED)\n        .replace(/\\r/g, SYMBOL_FOR_CARRIAGE_RETURN);\n  }\n  return String(obj);\n}\n\n// ----------------- Trace -----------------\n\nfunction Trace(inputStream, pos, expr, ans, optChildren) {\n  this.children = optChildren || [];\n  this.expr = expr;\n  if (ans) {\n    this.interval = new Interval(inputStream, pos, inputStream.pos);\n  }\n  this.isLeftRecursive = false;\n  this.pos = pos;\n  this.inputStream = inputStream;\n  this.succeeded = !!ans;\n}\n\n// A value that can be returned from visitor functions to indicate that a\n// node should not be recursed into.\nTrace.prototype.SKIP = {};\n\nObject.defineProperty(Trace.prototype, 'displayString', {\n  get: function() { return this.expr.toDisplayString(); }\n});\n\nTrace.prototype.setLeftRecursive = function(leftRecursive) {\n  this.isLeftRecursive = leftRecursive;\n  if (leftRecursive) {\n    linkLeftRecursiveChildren(this.children);\n  }\n};\n\n// Recursively traverse this trace node and all its descendents, calling a visitor function\n// for each node that is visited. If `vistorObjOrFn` is an object, then its 'enter' property\n// is a function to call before visiting the children of a node, and its 'exit' property is\n// a function to call afterwards. If `visitorObjOrFn` is a function, it represents the 'enter'\n// function.\n//\n// The functions are called with three arguments: the Trace node, its parent Trace, and a number\n// representing the depth of the node in the tree. (The root node has depth 0.) `optThisArg`, if\n// specified, is the value to use for `this` when executing the visitor functions.\nTrace.prototype.walk = function(visitorObjOrFn, optThisArg) {\n  var visitor = visitorObjOrFn;\n  if (typeof visitor === 'function') {\n    visitor = {enter: visitor};\n  }\n  return (function _walk(node, parent, depth) {\n    var recurse = true;\n    if (visitor.enter) {\n      if (visitor.enter.call(optThisArg, node, parent, depth) === Trace.prototype.SKIP) {\n        recurse = false;\n      }\n    }\n    if (recurse) {\n      node.children.forEach(function(c) {\n        if (c && ('walk' in c)) {\n          _walk(c, node, depth + 1);\n        }\n      });\n      if (visitor.exit) {\n        visitor.exit.call(optThisArg, node, parent, depth);\n      }\n    }\n  })(this, null, 0);\n};\n\n// Return a string representation of the trace.\n// Sample:\n//     12â‹…+â‹…2â‹…*â‹…3 âœ“ exp â‡’  \"12\"\n//     12â‹…+â‹…2â‹…*â‹…3   âœ“ addExp (LR) â‡’  \"12\"\n//     12â‹…+â‹…2â‹…*â‹…3       âœ— addExp_plus\nTrace.prototype.toString = function() {\n  var sb = new common.StringBuffer();\n  this.walk(function(node, parent, depth) {\n    var ctorName = node.expr.constructor.name;\n    if (ctorName === 'Alt') {\n      return;  // Don't print anything for Alt nodes.\n    }\n    sb.append(getInputExcerpt(node.inputStream, node.pos, 10) + spaces(depth * 2 + 1));\n    sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + ' ' + node.displayString);\n    if (node.isLeftRecursive) {\n      sb.append(' (LR)');\n    }\n    if (node.succeeded) {\n      var contents = asEscapedString(node.interval.contents);\n      sb.append(' ' + RIGHTWARDS_DOUBLE_ARROW + '  ');\n      sb.append(typeof contents === 'string' ? '\"' + contents + '\"' : contents);\n    }\n    sb.append('\\n');\n  });\n  return sb.contents();\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = Trace;\n","deps":{"./Interval":"/Users/dubroy/dev/cdg/ohm/src/Interval.js","./common":"/Users/dubroy/dev/cdg/ohm/src/common.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/Trace.js","sourceRoot":"file://localhost","sourceFile":"src/Trace.js"},"/Users/dubroy/dev/cdg/ohm/src/common.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/common.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar extend = require('util-extend');\n\n// --------------------------------------------------------------------\n// Private Stuff\n// --------------------------------------------------------------------\n\n// Helpers\n\nvar escapeStringFor = {};\nfor (var c = 0; c < 128; c++) {\n  escapeStringFor[c] = String.fromCharCode(c);\n}\nescapeStringFor[\"'\".charCodeAt(0)]  = \"\\\\'\";\nescapeStringFor['\"'.charCodeAt(0)]  = '\\\\\"';\nescapeStringFor['\\\\'.charCodeAt(0)] = '\\\\\\\\';\nescapeStringFor['\\b'.charCodeAt(0)] = '\\\\b';\nescapeStringFor['\\f'.charCodeAt(0)] = '\\\\f';\nescapeStringFor['\\n'.charCodeAt(0)] = '\\\\n';\nescapeStringFor['\\r'.charCodeAt(0)] = '\\\\r';\nescapeStringFor['\\t'.charCodeAt(0)] = '\\\\t';\nescapeStringFor['\\u000b'.charCodeAt(0)] = '\\\\v';\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nexports.abstract = function() {\n  throw new Error(\n      'this method is abstract! ' +\n      '(it has no implementation in class ' + this.constructor.name + ')');\n};\n\nexports.assert = function(cond, message) {\n  if (!cond) {\n    throw new Error(message);\n  }\n};\n\n// Define a lazily-computed, non-enumerable property named `propName`\n// on the object `obj`. `getterFn` will be called to compute the value the\n// first time the property is accessed.\nexports.defineLazyProperty = function(obj, propName, getterFn) {\n  var memo;\n  Object.defineProperty(obj, propName, {\n    get: function() {\n      if (!memo) {\n        memo = getterFn.call(this);\n      }\n      return memo;\n    }\n  });\n};\n\nexports.clone = function(obj) {\n  if (obj) {\n    return extend({}, obj);\n  }\n  return obj;\n};\n\nexports.extend = extend;\n\nexports.repeatFn = function(fn, n) {\n  var arr = [];\n  while (n-- > 0) {\n    arr.push(fn());\n  }\n  return arr;\n};\n\nexports.repeatStr = function(str, n) {\n  return new Array(n + 1).join(str);\n};\n\nexports.repeat = function(x, n) {\n  return exports.repeatFn(function() { return x; }, n);\n};\n\nexports.getDuplicates = function(array) {\n  var duplicates = [];\n  for (var idx = 0; idx < array.length; idx++) {\n    var x = array[idx];\n    if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {\n      duplicates.push(x);\n    }\n  }\n  return duplicates;\n};\n\nexports.fail = {};\n\nexports.isSyntactic = function(ruleName) {\n  var firstChar = ruleName[0];\n  return ('A' <= firstChar && firstChar <= 'Z');\n};\n\nexports.padLeft = function(str, len, optChar) {\n  var ch = optChar || ' ';\n  if (str.length < len) {\n    return exports.repeatStr(ch, len - str.length) + str;\n  }\n  return str;\n};\n\n// StringBuffer\n\nexports.StringBuffer = function() {\n  this.strings = [];\n};\n\nexports.StringBuffer.prototype.append = function(str) {\n  this.strings.push(str);\n};\n\nexports.StringBuffer.prototype.contents = function() {\n  return this.strings.join('');\n};\n\n// Character escaping and unescaping\n\nexports.escapeChar = function(c, optDelim) {\n  var charCode = c.charCodeAt(0);\n  if ((c === '\"' || c === \"'\") && optDelim && c !== optDelim) {\n    return c;\n  } else if (charCode < 128) {\n    return escapeStringFor[charCode];\n  } else if (128 <= charCode && charCode < 256) {\n    return '\\\\x' + exports.padLeft(charCode.toString(16), 2, '0');\n  } else {\n    return '\\\\u' + exports.padLeft(charCode.toString(16), 4, '0');\n  }\n};\n\nexports.unescapeChar = function(s) {\n  if (s.charAt(0) === '\\\\') {\n    switch (s.charAt(1)) {\n      case 'b': return '\\b';\n      case 'f': return '\\f';\n      case 'n': return '\\n';\n      case 'r': return '\\r';\n      case 't': return '\\t';\n      case 'v': return '\\v';\n      case 'x': return String.fromCharCode(parseInt(s.substring(2, 4), 16));\n      case 'u': return String.fromCharCode(parseInt(s.substring(2, 6), 16));\n      default:   return s.charAt(1);\n    }\n  } else {\n    return s;\n  }\n};\n\n// Helper for producing a description of an unknown object in a safe way.\n// Especially useful for error messages where an unexpected type of object was encountered.\nexports.unexpectedObjToString = function(obj) {\n  if (obj == null) {\n    return String(obj);\n  }\n  var baseToString = Object.prototype.toString.call(obj);\n  try {\n    var typeName;\n    if (obj.constructor && obj.constructor.name) {\n      typeName = obj.constructor.name;\n    } else if (baseToString.indexOf('[object ') === 0) {\n      typeName = baseToString.slice(8, -1);  // Extract e.g. \"Array\" from \"[object Array]\".\n    } else {\n      typeName = typeof obj;\n    }\n    return typeName + ': ' + JSON.stringify(String(obj));\n  } catch (e) {\n    return baseToString;\n  }\n};\n","deps":{"util-extend":"/Users/dubroy/dev/cdg/ohm/node_modules/util-extend/extend.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/common.js","sourceRoot":"file://localhost","sourceFile":"src/common.js"},"/Users/dubroy/dev/cdg/ohm/src/errors.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/errors.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar Namespace = require('./Namespace');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction createError(message, optInterval) {\n  var e;\n  if (optInterval) {\n    e = new Error(optInterval.getLineAndColumnMessage() + message);\n    e.shortMessage = message;\n    e.interval = optInterval;\n  } else {\n    e = new Error(message);\n  }\n  return e;\n}\n\n// ----------------- errors about intervals -----------------\n\nfunction intervalSourcesDontMatch() {\n  return createError(\"Interval sources don't match\");\n}\n\n// ----------------- errors about grammars -----------------\n\n// Grammar syntax error\n\nfunction grammarSyntaxError(matchFailure) {\n  var e = new Error();\n  Object.defineProperty(e, 'message', {get: function() { return matchFailure.message; }});\n  Object.defineProperty(e, 'shortMessage', {get: function() {\n    return 'Expected ' + matchFailure.getExpectedText();\n  }});\n  e.interval = matchFailure.getInterval();\n  return e;\n}\n\n// Undeclared grammar\n\nfunction undeclaredGrammar(grammarName, namespace, interval) {\n  var message = namespace ?\n      'Grammar ' + grammarName + ' is not declared in namespace ' + Namespace.toString(namespace) :\n      'Undeclared grammar ' + grammarName;\n  return createError(message, interval);\n}\n\n// Duplicate grammar declaration\n\nfunction duplicateGrammarDeclaration(grammar, namespace) {\n  return createError('Grammar ' + grammar.name + ' is already declared in this namespace');\n}\n\n// ----------------- rules -----------------\n\n// Undeclared rule\n\nfunction undeclaredRule(ruleName, grammarName, expr) {\n  return createError(\n      'Rule ' + ruleName + ' is not declared in grammar ' + grammarName,\n      expr.interval);\n}\n\n// Cannot override undeclared rule\n\nfunction cannotOverrideUndeclaredRule(ruleName, grammarName, body) {\n  return createError(\n      'Cannot override rule ' + ruleName + ' because it is not declared in ' + grammarName,\n      body.definitionInterval);\n}\n\n// Cannot extend undeclared rule\n\nfunction cannotExtendUndeclaredRule(ruleName, grammarName, body) {\n  return createError(\n      'Cannot extend rule ' + ruleName + ' because it is not declared in ' + grammarName,\n      body.definitionInterval);\n}\n\n// Duplicate rule declaration\n\nfunction duplicateRuleDeclaration(ruleName, offendingGrammarName, declGrammarName, body) {\n  var message = \"Duplicate declaration for rule '\" + ruleName +\n      \"' in grammar '\" + offendingGrammarName + \"'\";\n  if (offendingGrammarName !== declGrammarName) {\n    message += \" (originally declared in '\" + declGrammarName + \"')\";\n  }\n  return createError(message, body.definitionInterval);\n}\n\n// Wrong number of parameters\n\nfunction wrongNumberOfParameters(ruleName, expected, actual, body) {\n  return createError(\n      'Wrong number of parameters for rule ' + ruleName +\n          ' (expected ' + expected + ', got ' + actual + ')',\n      // FIXME: the definition interval is OK if this error is about a definition, but not a call.\n      // Should probably split this up into two errors.\n      body.definitionInterval);\n}\n\n// Duplicate parameter names\n\nfunction duplicateParameterNames(ruleName, duplicates, body) {\n  return createError(\n      'Duplicate parameter names in rule ' + ruleName + ': ' + duplicates.join(','),\n      body.definitionInterval);\n}\n\n// Invalid parameter expression\n\nfunction invalidParameter(ruleName, expr) {\n  return createError(\n      'Invalid parameter to rule ' + ruleName + ': ' + expr + ' has arity ' + expr.getArity() +\n          ', but parameter expressions ' + 'must have arity 1',\n      expr.interval);\n}\n\n// Application of syntactic rule from lexical rule\n\nfunction applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {\n  return createError(\n      'Cannot apply syntactic rule ' + ruleName + ' from here (inside a lexical context)',\n      applyExpr.interval);\n}\n\n// ----------------- Kleene operators -----------------\n\nfunction kleeneExprHasNullableOperand(kleeneExpr) {\n  return createError(\n      'Nullable expression ' + kleeneExpr.expr.interval.contents + \" is not allowed inside '\" +\n          kleeneExpr.operator + \"' (possible infinite loop)\",\n      kleeneExpr.expr.interval);\n}\n\n// ----------------- arity -----------------\n\nfunction inconsistentArity(ruleName, expected, actual, expr) {\n  return createError(\n      'Rule ' + ruleName + ' involves an alternation which has inconsistent arity ' +\n          '(expected ' + expected + ', got ' + actual + ')',\n      expr.interval);\n}\n\n// ----------------- properties -----------------\n\nfunction duplicatePropertyNames(duplicates) {\n  return createError('Object pattern has duplicate property names: ' + duplicates.join(', '));\n}\n\n// ----------------- constructors -----------------\n\nfunction invalidConstructorCall(grammar, ctorName, children) {\n  return createError(\n      'Attempt to invoke constructor ' + ctorName + ' with invalid or unexpected arguments');\n}\n\n// ----------------- convenience -----------------\n\nfunction multipleErrors(errors) {\n  var messages = errors.map(function(e) { return e.message; });\n  return createError(\n      ['Errors:'].concat(messages).join('\\n- '),\n      errors[0].interval);\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = {\n  applicationOfSyntacticRuleFromLexicalContext: applicationOfSyntacticRuleFromLexicalContext,\n  cannotExtendUndeclaredRule: cannotExtendUndeclaredRule,\n  cannotOverrideUndeclaredRule: cannotOverrideUndeclaredRule,\n  duplicateGrammarDeclaration: duplicateGrammarDeclaration,\n  duplicateParameterNames: duplicateParameterNames,\n  duplicatePropertyNames: duplicatePropertyNames,\n  duplicateRuleDeclaration: duplicateRuleDeclaration,\n  inconsistentArity: inconsistentArity,\n  intervalSourcesDontMatch: intervalSourcesDontMatch,\n  invalidConstructorCall: invalidConstructorCall,\n  invalidParameter: invalidParameter,\n  grammarSyntaxError: grammarSyntaxError,\n  kleeneExprHasNullableOperand: kleeneExprHasNullableOperand,\n  undeclaredGrammar: undeclaredGrammar,\n  undeclaredRule: undeclaredRule,\n  wrongNumberOfParameters: wrongNumberOfParameters,\n\n  throwErrors: function(errors) {\n    if (errors.length === 1) {\n      throw errors[0];\n    }\n    if (errors.length > 1) {\n      throw multipleErrors(errors);\n    }\n  }\n};\n","deps":{"./Namespace":"/Users/dubroy/dev/cdg/ohm/src/Namespace.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/errors.js","sourceRoot":"file://localhost","sourceFile":"src/errors.js"},"/Users/dubroy/dev/cdg/ohm/src/fsets.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/fsets.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n/*\n  `FSet`s, or \"failure sets\", are (immutable) sets of parsing expressions that failed to match the\n  input. The interface of `FSets` includes:\n\n  - union(fset) : FSet\n  - asFluffy() : FSet\n  - isFluffy(PExpr) : bool\n  - includes(PExpr) : bool\n  - toFailuresArray(grammar) : [Failure]\n*/\n\nvar empty;\n\n// The FSet \"abstract class\"\n\nfunction FSet() {}\n\nFSet.prototype.asFluffy = function() {\n  return new Fluffy(this);\n};\nFSet.prototype.union = function(fs) {\n  return fs === empty ?\n      this :\n      new Union(fs, this);\n};\n\n// Empty FSet\n\nempty = new FSet();\nempty.union = function(fs) {\n  return fs;\n};\nempty.includes = function(pexpr) {\n  return false;\n};\nempty.asFluffy = function() {\n  return this;\n};\nempty.isFluffy = function(pexpr) {\n  throw new Error('uh-oh');\n};\nempty.toFailuresArray = function(grammar) {\n  return [];\n};\n\n// Singleton FSet, i.e., an FSet that contains a single parsing expression.\n\nfunction Singleton(pexpr) {\n  this.pexpr = pexpr;\n}\nSingleton.prototype = Object.create(FSet.prototype);\nSingleton.prototype.includes = function(pexpr) {\n  return pexpr === this.pexpr;\n};\nSingleton.prototype.isFluffy = function(pexpr) {\n  return false;\n};\nSingleton.prototype.toFailuresArray = function(grammar) {\n  return [this.pexpr.toFailure(grammar)];\n};\n\n// Fluffy FSet\n\nfunction Fluffy(fs) {\n  this.fs = fs;\n}\nFluffy.prototype = Object.create(FSet.prototype);\nFluffy.prototype.includes = function(pexpr) {\n  return this.fs.includes(pexpr);\n};\nFluffy.prototype.asFluffy = function() {\n  return this;\n};\nFluffy.prototype.isFluffy = function(pexpr) {\n  return true;\n};\nFluffy.prototype.toFailuresArray = function(grammar) {\n  var fs = this.fs.toFailuresArray(grammar);\n  fs.forEach(function(f) {\n    f.makeFluffy();\n  });\n  return fs;\n};\n\n// Union FSet\n\nfunction Union(fs1, fs2) {\n  this.fs1 = fs1;\n  this.fs2 = fs2;\n}\nUnion.prototype = Object.create(FSet.prototype);\nUnion.prototype.includes = function(pexpr) {\n  return this.fs1.includes(pexpr) || this.fs2.includes(pexpr);\n};\nUnion.prototype.isFluffy = function(pexpr) {\n  return !(this.fs1.includes(pexpr) && !this.fs1.isFluffy(pexpr) ||\n           this.fs2.includes(pexpr) && !this.fs2.isFluffy(pexpr));\n};\nUnion.prototype.toFailuresArray = function(grammar) {\n  var arr = this.fs1.toFailuresArray(grammar);\n  var fs = this.fs2.toFailuresArray(grammar);\n  fs.forEach(function(f) {\n    for (var idx = 0; idx < arr.length; idx++) {\n      var otherF = arr[idx];\n      if (f.subsumes(otherF)) {\n        // Replace the failure that is subsumed by f\n        arr[idx] = f;\n        return;\n      }\n      if (otherF.subsumes(f)) {\n        // f shouldn't be included in the array, since it's subsumed\n        return;\n      }\n    }\n    // f is neither subsumed by or subsumes another failure, so add it to the array\n    arr.push(f);\n  });\n  return arr;\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nexports.empty = empty;\nexports.Singleton = Singleton;\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/src/fsets.js","sourceRoot":"file://localhost","sourceFile":"src/fsets.js"},"/Users/dubroy/dev/cdg/ohm/src/nodes.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/nodes.js","source":"'use strict';\n\nvar inherits = require('inherits');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction Node(grammar, ctorName, children, interval) {\n  this.grammar = grammar;\n  this.ctorName = ctorName;\n  this.children = children;\n  this.interval = interval;\n}\n\nNode.prototype.numChildren = function() {\n  return this.children.length;\n};\n\nNode.prototype.childAt = function(idx) {\n  return this.children[idx];\n};\n\nNode.prototype.indexOfChild = function(arg) {\n  return this.children.indexOf(arg);\n};\n\nNode.prototype.hasChildren = function() {\n  return this.children.length > 0;\n};\n\nNode.prototype.hasNoChildren = function() {\n  return !this.hasChildren();\n};\n\nNode.prototype.onlyChild = function() {\n  if (this.children.length !== 1) {\n    throw new Error(\n        'cannot get only child of a node of type ' + this.ctorName +\n        ' (it has ' + this.numChildren() + ' children)');\n  } else {\n    return this.firstChild();\n  }\n};\n\nNode.prototype.firstChild = function() {\n  if (this.hasNoChildren()) {\n    throw new Error(\n        'cannot get first child of a ' + this.ctorName + ' node, which has no children');\n  } else {\n    return this.childAt(0);\n  }\n};\n\nNode.prototype.lastChild = function() {\n  if (this.hasNoChildren()) {\n    throw new Error(\n        'cannot get last child of a ' + this.ctorName + ' node, which has no children');\n  } else {\n    return this.childAt(this.numChildren() - 1);\n  }\n};\n\nNode.prototype.childBefore = function(child) {\n  var childIdx = this.indexOfChild(child);\n  if (childIdx < 0) {\n    throw new Error('Node.childBefore() called w/ an argument that is not a child');\n  } else if (childIdx === 0) {\n    throw new Error('cannot get child before first child');\n  } else {\n    return this.childAt(childIdx - 1);\n  }\n};\n\nNode.prototype.childAfter = function(child) {\n  var childIdx = this.indexOfChild(child);\n  if (childIdx < 0) {\n    throw new Error('Node.childAfter() called w/ an argument that is not a child');\n  } else if (childIdx === this.numChildren() - 1) {\n    throw new Error('cannot get child after last child');\n  } else {\n    return this.childAt(childIdx + 1);\n  }\n};\n\nNode.prototype.isTerminal = function() {\n  return false;\n};\n\nNode.prototype.toJSON = function() {\n  var r = {};\n  r[this.ctorName] = this.children;\n  return r;\n};\n\nfunction TerminalNode(grammar, value, interval) {\n  Node.call(this, grammar, '_terminal', [], interval);\n  this.primitiveValue = value;\n}\ninherits(TerminalNode, Node);\n\nTerminalNode.prototype.isTerminal = function() {\n  return true;\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = {Node: Node, TerminalNode: TerminalNode};\n","deps":{"inherits":"/Users/dubroy/dev/cdg/ohm/node_modules/inherits/inherits_browser.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/nodes.js","sourceRoot":"file://localhost","sourceFile":"src/nodes.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertAllApplicationsAreValid.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertAllApplicationsAreValid.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar errors = require('./errors');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nvar lexifyCount;\n\npexprs.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar) {\n  lexifyCount = 0;\n  this._assertAllApplicationsAreValid(ruleName, grammar);\n};\n\npexprs.PExpr.prototype._assertAllApplicationsAreValid = common.abstract;\n\npexprs.any._assertAllApplicationsAreValid =\npexprs.end._assertAllApplicationsAreValid =\npexprs.Prim.prototype._assertAllApplicationsAreValid =\npexprs.Range.prototype._assertAllApplicationsAreValid =\npexprs.Param.prototype._assertAllApplicationsAreValid =\npexprs.UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  // no-op\n};\n\npexprs.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  lexifyCount++;\n  this.expr._assertAllApplicationsAreValid(ruleName, grammar);\n  lexifyCount--;\n};\n\npexprs.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  for (var idx = 0; idx < this.terms.length; idx++) {\n    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar);\n  }\n};\n\npexprs.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  for (var idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar);\n  }\n};\n\npexprs.Iter.prototype._assertAllApplicationsAreValid =\npexprs.Not.prototype._assertAllApplicationsAreValid =\npexprs.Lookahead.prototype._assertAllApplicationsAreValid =\npexprs.Arr.prototype._assertAllApplicationsAreValid =\npexprs.Str.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  this.expr._assertAllApplicationsAreValid(ruleName, grammar);\n};\n\npexprs.Obj.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  for (var idx = 0; idx < this.properties.length; idx++) {\n    this.properties[idx].pattern._assertAllApplicationsAreValid(ruleName, grammar);\n  }\n};\n\npexprs.Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  var body = grammar.ruleBodies[this.ruleName];\n\n  // Make sure that the rule exists\n  if (!body) {\n    throw errors.undeclaredRule(this.ruleName, grammar.name, this);\n  }\n\n  // ... and that this application is allowed\n  if (common.isSyntactic(this.ruleName) && (!common.isSyntactic(ruleName) || lexifyCount > 0)) {\n    throw errors.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);\n  }\n\n  // ... and that this application has the correct number of parameters\n  var actual = this.params.length;\n  var expected = grammar.ruleFormals[this.ruleName].length;\n  if (actual !== expected) {\n    throw errors.wrongNumberOfParameters(this.ruleName, expected, actual, this);\n  }\n\n  // ... and that all of the parameter expressions only have valid applications and have arity 1\n  var self = this;\n  this.params.forEach(function(param) {\n    param._assertAllApplicationsAreValid(ruleName, grammar);\n    if (param.getArity() !== 1) {\n      throw errors.invalidParameter(self.ruleName, param);\n    }\n  });\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./errors":"/Users/dubroy/dev/cdg/ohm/src/errors.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertAllApplicationsAreValid.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-assertAllApplicationsAreValid.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertChoicesHaveUniformArity.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertChoicesHaveUniformArity.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar errors = require('./errors');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.assertChoicesHaveUniformArity = common.abstract;\n\npexprs.any.assertChoicesHaveUniformArity =\npexprs.end.assertChoicesHaveUniformArity =\npexprs.Prim.prototype.assertChoicesHaveUniformArity =\npexprs.Range.prototype.assertChoicesHaveUniformArity =\npexprs.Param.prototype.assertChoicesHaveUniformArity =\npexprs.Lex.prototype.assertChoicesHaveUniformArity =\npexprs.UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // no-op\n};\n\npexprs.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  if (this.terms.length === 0) {\n    return;\n  }\n  var arity = this.terms[0].getArity();\n  for (var idx = 0; idx < this.terms.length; idx++) {\n    var term = this.terms[idx];\n    term.assertChoicesHaveUniformArity();\n    var otherArity = term.getArity();\n    if (arity !== otherArity) {\n      throw errors.inconsistentArity(ruleName, arity, otherArity, this);\n    }\n  }\n};\n\npexprs.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // Extend is a special case of Alt that's guaranteed to have exactly two\n  // cases: [extensions, origBody].\n  var actualArity = this.terms[0].getArity();\n  var expectedArity = this.terms[1].getArity();\n  if (actualArity !== expectedArity) {\n    throw errors.inconsistentArity(ruleName, expectedArity, actualArity, this);\n  }\n};\n\npexprs.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  for (var idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx].assertChoicesHaveUniformArity(ruleName);\n  }\n};\n\npexprs.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  this.expr.assertChoicesHaveUniformArity(ruleName);\n};\n\npexprs.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // no-op (not required b/c the nested expr doesn't show up in the CST)\n};\n\npexprs.Lookahead.prototype.assertChoicesHaveUniformArity =\npexprs.Arr.prototype.assertChoicesHaveUniformArity =\npexprs.Str.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  this.expr.assertChoicesHaveUniformArity(ruleName);\n};\n\npexprs.Obj.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  for (var idx = 0; idx < this.properties.length; idx++) {\n    this.properties[idx].pattern.assertChoicesHaveUniformArity(ruleName);\n  }\n};\n\npexprs.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // The arities of the parameter expressions is required to be 1 by\n  // `assertAllApplicationsAreValid()`.\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./errors":"/Users/dubroy/dev/cdg/ohm/src/errors.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertChoicesHaveUniformArity.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-assertChoicesHaveUniformArity.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertIteratedExprsAreNotNullable.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertIteratedExprsAreNotNullable.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar errors = require('./errors');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.assertIteratedExprsAreNotNullable = common.abstract;\n\npexprs.any.assertIteratedExprsAreNotNullable =\npexprs.end.assertIteratedExprsAreNotNullable =\npexprs.Prim.prototype.assertIteratedExprsAreNotNullable =\npexprs.Prim.prototype.assertIteratedExprsAreNotNullable =\npexprs.Range.prototype.assertIteratedExprsAreNotNullable =\npexprs.Param.prototype.assertIteratedExprsAreNotNullable =\npexprs.UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar, ruleName) {\n  // no-op\n};\n\npexprs.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar, ruleName) {\n  for (var idx = 0; idx < this.terms.length; idx++) {\n    this.terms[idx].assertIteratedExprsAreNotNullable(grammar, ruleName);\n  }\n};\n\npexprs.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar, ruleName) {\n  for (var idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx].assertIteratedExprsAreNotNullable(grammar, ruleName);\n  }\n};\n\npexprs.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar, ruleName) {\n  // Note: this is the implementation of this method for `Star` and `Plus` expressions.\n  // It is overridden for `Opt` below.\n  this.expr.assertIteratedExprsAreNotNullable(grammar, ruleName);\n  if (this.expr.isNullable(grammar)) {\n    throw errors.kleeneExprHasNullableOperand(this, ruleName);\n  }\n};\n\npexprs.Opt.prototype.assertIteratedExprsAreNotNullable =\npexprs.Not.prototype.assertIteratedExprsAreNotNullable =\npexprs.Lookahead.prototype.assertIteratedExprsAreNotNullable =\npexprs.Lex.prototype.assertIteratedExprsAreNotNullable =\npexprs.Arr.prototype.assertIteratedExprsAreNotNullable =\npexprs.Str.prototype.assertIteratedExprsAreNotNullable = function(grammar, ruleName) {\n  this.expr.assertIteratedExprsAreNotNullable(grammar, ruleName);\n};\n\npexprs.Obj.prototype.assertIteratedExprsAreNotNullable = function(grammar, ruleName) {\n  for (var idx = 0; idx < this.properties.length; idx++) {\n    this.properties[idx].pattern.assertIteratedExprsAreNotNullable(grammar, ruleName);\n  }\n};\n\npexprs.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar, ruleName) {\n  this.params.forEach(function(param) {\n    param.assertIteratedExprsAreNotNullable(grammar, ruleName);\n  });\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./errors":"/Users/dubroy/dev/cdg/ohm/src/errors.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertIteratedExprsAreNotNullable.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-assertIteratedExprsAreNotNullable.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-check.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-check.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar nodes = require('./nodes');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.check = common.abstract;\n\npexprs.any.check = function(grammar, vals) {\n  return vals.length >= 1;\n};\n\npexprs.end.check = function(grammar, vals) {\n  return vals[0] instanceof nodes.Node &&\n         vals[0].isTerminal() &&\n         vals[0].primitiveValue === undefined;\n};\n\npexprs.Prim.prototype.check = function(grammar, vals) {\n  return vals[0] instanceof nodes.Node &&\n         vals[0].isTerminal() &&\n         vals[0].primitiveValue === this.obj;\n};\n\npexprs.Range.prototype.check = function(grammar, vals) {\n  return vals[0] instanceof nodes.Node &&\n         vals[0].isTerminal() &&\n         typeof vals[0].primitiveValue === typeof this.from;\n};\n\npexprs.Param.prototype.check = function(grammar, vals) {\n  return vals.length >= 1;\n};\n\npexprs.Alt.prototype.check = function(grammar, vals) {\n  for (var i = 0; i < this.terms.length; i++) {\n    var term = this.terms[i];\n    if (term.check(grammar, vals)) {\n      return true;\n    }\n  }\n  return false;\n};\n\npexprs.Seq.prototype.check = function(grammar, vals) {\n  var pos = 0;\n  for (var i = 0; i < this.factors.length; i++) {\n    var factor = this.factors[i];\n    if (factor.check(grammar, vals.slice(pos))) {\n      pos += factor.getArity();\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\npexprs.Iter.prototype.check = function(grammar, vals) {\n  var arity = this.getArity();\n  var columns = vals.slice(0, arity);\n  if (columns.length !== arity) {\n    return false;\n  }\n  var rowCount = columns[0].length;\n  var i;\n  for (i = 1; i < arity; i++) {\n    if (columns[i].length !== rowCount) {\n      return false;\n    }\n  }\n\n  for (i = 0; i < rowCount; i++) {\n    var row = [];\n    for (var j = 0; j < arity; j++) {\n      row.push(columns[j][i]);\n    }\n    if (!this.expr.check(grammar, row)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\npexprs.Not.prototype.check = function(grammar, vals) {\n  return true;\n};\n\npexprs.Lookahead.prototype.check =\npexprs.Lex.prototype.check =\npexprs.Arr.prototype.check =\npexprs.Str.prototype.check = function(grammar, vals) {\n  return this.expr.check(grammar, vals);\n};\n\npexprs.Obj.prototype.check = function(grammar, vals) {\n  var fixedArity = this.getArity();\n  if (this.isLenient) {\n    fixedArity--;\n  }\n\n  var pos = 0;\n  for (var i = 0; i < fixedArity; i++) {\n    var pattern = this.properties[i].pattern;\n    if (pattern.check(grammar, vals.slice(pos))) {\n      pos += pattern.getArity();\n    } else {\n      return false;\n    }\n  }\n\n  return this.isLenient ? typeof vals[pos] === 'object' && vals[pos] : true;\n};\n\npexprs.Apply.prototype.check = function(grammar, vals) {\n  if (!(vals[0] instanceof nodes.Node &&\n        vals[0].grammar === grammar &&\n        vals[0].ctorName === this.ruleName)) {\n    return false;\n  }\n\n  // TODO: think about *not* doing the following checks, i.e., trusting that the rule\n  // was correctly constructed.\n  var ruleNode = vals[0];\n  var body = grammar.ruleBodies[this.ruleName];\n  return body.check(grammar, ruleNode.children) && ruleNode.numChildren() === body.getArity();\n};\n\npexprs.UnicodeChar.prototype.check = function(grammar, vals) {\n  return vals[0] instanceof nodes.Node &&\n         vals[0].isTerminal() &&\n         typeof vals[0].primitiveValue === 'string';\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js","./nodes":"/Users/dubroy/dev/cdg/ohm/src/nodes.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-check.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-check.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-eval.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-eval.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar InputStream = require('./InputStream');\nvar Trace = require('./Trace');\nvar common = require('./common');\nvar fsets = require('./fsets');\nvar nodes = require('./nodes');\nvar pexprs = require('./pexprs');\n\nvar Node = nodes.Node;\nvar TerminalNode = nodes.TerminalNode;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Evaluate the expression and return `true` if it succeeds, `false` otherwise. This method should\n  only be called directly by `State.prototype.eval(expr)`, which also updates the data structures\n  that are used for tracing. (Making those updates in a method of `State` enables the trace-specific\n  data structures to be \"secrets\" of that class, which is good for modularity.)\n\n  The contract of this method is as follows:\n  * When the return value is `true`,\n    - the state object will have `expr.getArity()` more bindings than it did before the call.\n  * When the return value is `false`,\n    - the state object may have more bindings than it did before the call, and\n    - its input stream's position may be anywhere.\n\n  Note that `State.prototype.eval(expr)`, unlike this method, guarantees that neither the state\n  object's bindings nor its input stream's position will change if the expression fails to match.\n*/\npexprs.PExpr.prototype.eval = common.abstract;  // function(state) { ... }\n\npexprs.any.eval = function(state) {\n  var origPos = state.skipSpacesIfInSyntacticContext();\n  var inputStream = state.inputStream;\n  var value = inputStream.next();\n  if (value === common.fail) {\n    state.processFailure(origPos, this);\n    return false;\n  } else {\n    var interval = inputStream.interval(origPos);\n    state.bindings.push(new TerminalNode(state.grammar, value, interval));\n    return true;\n  }\n};\n\npexprs.end.eval = function(state) {\n  var origPos = state.skipSpacesIfInSyntacticContext();\n  var inputStream = state.inputStream;\n  if (inputStream.atEnd()) {\n    var interval = inputStream.interval(inputStream.pos);\n    state.bindings.push(new TerminalNode(state.grammar, undefined, interval));\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\npexprs.Prim.prototype.eval = function(state) {\n  var origPos = state.skipSpacesIfInSyntacticContext();\n  var inputStream = state.inputStream;\n  if (this.match(inputStream) === common.fail) {\n    state.processFailure(origPos, this);\n    return false;\n  } else {\n    var interval = inputStream.interval(origPos);\n    var primitiveValue = this.obj;\n    state.bindings.push(new TerminalNode(state.grammar, primitiveValue, interval));\n    return true;\n  }\n};\n\npexprs.Prim.prototype.match = function(inputStream) {\n  return typeof this.obj === 'string' ?\n      inputStream.matchString(this.obj) :\n      inputStream.matchExactly(this.obj);\n};\n\npexprs.Range.prototype.eval = function(state) {\n  var origPos = state.skipSpacesIfInSyntacticContext();\n  var inputStream = state.inputStream;\n  var obj = inputStream.next();\n  if (typeof obj === typeof this.from && this.from <= obj && obj <= this.to) {\n    var interval = inputStream.interval(origPos);\n    state.bindings.push(new TerminalNode(state.grammar, obj, interval));\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\npexprs.Param.prototype.eval = function(state) {\n  return state.eval(state.currentApplication().params[this.index]);\n};\n\npexprs.Lex.prototype.eval = function(state) {\n  state.enterLexifiedContext();\n  var ans = state.eval(this.expr);\n  state.exitLexifiedContext();\n  return ans;\n};\n\npexprs.Alt.prototype.eval = function(state) {\n  for (var idx = 0; idx < this.terms.length; idx++) {\n    if (state.eval(this.terms[idx])) {\n      return true;\n    }\n  }\n  return false;\n};\n\npexprs.Seq.prototype.eval = function(state) {\n  for (var idx = 0; idx < this.factors.length; idx++) {\n    var factor = this.factors[idx];\n    if (!state.eval(factor)) {\n      return false;\n    }\n  }\n  return true;\n};\n\npexprs.Iter.prototype.eval = function(state) {\n  var inputStream = state.inputStream;\n  var origPos = inputStream.pos;\n  var arity = this.getArity();\n  var cols = [];\n  while (cols.length < arity) {\n    cols.push([]);\n  }\n  var numMatches = 0;\n  var idx;\n  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {\n    numMatches++;\n    var row = state.bindings.splice(state.bindings.length - arity, arity);\n    for (idx = 0; idx < row.length; idx++) {\n      cols[idx].push(row[idx]);\n    }\n  }\n  if (numMatches < this.minNumMatches) {\n    return false;\n  }\n  var interval;\n  if (numMatches === 0) {\n    interval = inputStream.interval(origPos, origPos);\n  } else {\n    var firstCol = cols[0];\n    var lastCol = cols[cols.length - 1];\n    interval = inputStream.interval(\n        firstCol[0].interval.startIdx,\n        lastCol[lastCol.length - 1].interval.endIdx);\n  }\n  for (idx = 0; idx < cols.length; idx++) {\n    state.bindings.push(new Node(state.grammar, '_iter', cols[idx], interval));\n  }\n  return true;\n};\n\npexprs.Not.prototype.eval = function(state) {\n  /*\n    TODO:\n    - Right now we're just throwing away all of the failures that happen inside a `not`, and\n      recording `this` as a failed expression.\n    - Double negation should be equivalent to lookahead, but that's not the case right now wrt\n      failures. E.g., ~~'foo' produces a failure for ~~'foo', but maybe it should produce\n      a failure for 'foo' instead.\n  */\n\n  var inputStream = state.inputStream;\n  var origPos = inputStream.pos;\n  var failuresInfo = state.getFailuresInfo();\n\n  var ans = state.eval(this.expr);\n\n  state.restoreFailuresInfo(failuresInfo);\n  if (ans) {\n    state.processFailure(origPos, this);\n    return false;\n  }\n\n  inputStream.pos = origPos;\n  return true;\n};\n\npexprs.Lookahead.prototype.eval = function(state) {\n  var inputStream = state.inputStream;\n  var origPos = inputStream.pos;\n  if (state.eval(this.expr)) {\n    inputStream.pos = origPos;\n    return true;\n  } else {\n    return false;\n  }\n};\n\npexprs.Arr.prototype.eval = function(state) {\n  var obj = state.inputStream.next();\n  if (Array.isArray(obj)) {\n    var objInputStream = InputStream.newFor(obj);\n    state.pushInputStream(objInputStream);\n    var ans = state.eval(this.expr) && objInputStream.atEnd();\n    state.popInputStream();\n    return ans;\n  } else {\n    return false;\n  }\n};\n\npexprs.Str.prototype.eval = function(state) {\n  var obj = state.inputStream.next();\n  if (typeof obj === 'string') {\n    var strInputStream = InputStream.newFor(obj);\n    state.pushInputStream(strInputStream);\n    var ans = state.eval(this.expr) && state.eval(pexprs.end);\n    if (ans) {\n      // Pop the binding that was added by `end`, which we don't want.\n      state.bindings.pop();\n    }\n    state.popInputStream();\n    return ans;\n  } else {\n    return false;\n  }\n};\n\npexprs.Obj.prototype.eval = function(state) {\n  var inputStream = state.inputStream;\n  var origPos = inputStream.pos;\n  var obj = inputStream.next();\n  if (obj !== common.fail && obj && (typeof obj === 'object' || typeof obj === 'function')) {\n    var numOwnPropertiesMatched = 0;\n    for (var idx = 0; idx < this.properties.length; idx++) {\n      var property = this.properties[idx];\n      if (!obj.hasOwnProperty(property.name)) {\n        return false;\n      }\n      var value = obj[property.name];\n      var valueInputStream = InputStream.newFor([value]);\n      state.pushInputStream(valueInputStream);\n      var matched = state.eval(property.pattern) && valueInputStream.atEnd();\n      state.popInputStream();\n      if (!matched) {\n        return false;\n      }\n      numOwnPropertiesMatched++;\n    }\n    if (this.isLenient) {\n      var remainder = {};\n      for (var p in obj) {\n        if (obj.hasOwnProperty(p) && this.properties.indexOf(p) < 0) {\n          remainder[p] = obj[p];\n        }\n      }\n      var interval = inputStream.interval(origPos);\n      state.bindings.push(new TerminalNode(state.grammar, remainder, interval));\n      return true;\n    } else {\n      return numOwnPropertiesMatched === Object.keys(obj).length;\n    }\n  } else {\n    return false;\n  }\n};\n\npexprs.Apply.prototype.eval = function(state) {\n  var caller = state.currentApplication();\n  var actuals = caller ? caller.params : [];\n  var app = this.substituteParams(actuals);\n\n  // Skip whitespace at the application site, if the rule that's being applied is syntactic\n  if (app !== state.applySpaces_ && (app.isSyntactic() || state.inSyntacticContext())) {\n    state.skipSpaces();\n  }\n\n  var posInfo = state.getCurrentPosInfo();\n  if (posInfo.isActive(app)) {\n    // This rule is already active at this position, i.e., it is left-recursive.\n    return app.handleCycle(state);\n  }\n\n  var memoKey = app.toMemoKey();\n  var memoRec = posInfo.memo[memoKey];\n  return memoRec && posInfo.shouldUseMemoizedResult(memoRec) ?\n      state.useMemoizedResult(memoRec) :\n      app.reallyEval(state, !caller);\n};\n\npexprs.Apply.prototype.handleCycle = function(state) {\n  var posInfo = state.getCurrentPosInfo();\n  var currentLeftRecursion = posInfo.currentLeftRecursion;\n  var memoKey = this.toMemoKey();\n  var memoRec = posInfo.memo[memoKey];\n\n  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {\n    // We already know about this left recursion, but it's possible there are \"involved\n    // applications\" that we don't already know about, so...\n    memoRec.updateInvolvedApplicationMemoKeys();\n  } else if (!memoRec) {\n    // New left recursion detected! Memoize a failure to try to get a seed parse.\n    memoRec = posInfo.memo[memoKey] =\n        {pos: -1, value: false, failuresAtRightmostPosition: fsets.empty};\n    posInfo.startLeftRecursion(this, memoRec);\n  }\n  return state.useMemoizedResult(memoRec);\n};\n\npexprs.Apply.prototype.reallyEval = function(state, isTopLevelApplication) {\n  var inputStream = state.inputStream;\n  var origPos = inputStream.pos;\n  var origPosInfo = state.getCurrentPosInfo();\n  var body = state.grammar.ruleBodies[this.ruleName];\n  var description = state.grammar.ruleDescriptions[this.ruleName];\n\n  origPosInfo.enter(this);\n\n  if (description) {\n    var origFailuresInfo = state.getFailuresInfo();\n  }\n\n  var value = this.evalOnce(body, state);\n  var currentLR = origPosInfo.currentLeftRecursion;\n  var memoKey = this.toMemoKey();\n  var isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;\n  var memoized = true;\n  if (isHeadOfLeftRecursion) {\n    value = this.growSeedResult(body, state, origPos, currentLR, value);\n    origPosInfo.endLeftRecursion();\n  } else if (currentLR && currentLR.isInvolved(memoKey)) {\n    // Don't memoize the result\n    memoized = false;\n  } else {\n    origPosInfo.memo[memoKey] =\n        {pos: inputStream.pos, value: value, failuresAtRightmostPosition: state.rightmostFailures};\n  }\n\n  if (description) {\n    state.restoreFailuresInfo(origFailuresInfo);\n    if (!value) {\n      state.processFailure(origPos, this);\n    }\n    if (memoized) {\n      origPosInfo.memo[memoKey].failuresAtRightmostPosition = state.rightmostFailures;\n    }\n  }\n\n  // Record trace information in the memo table, so that it is available if the memoized result\n  // is used later.\n  if (state.isTracing() && origPosInfo.memo[memoKey]) {\n    var entry = state.getTraceEntry(origPos, this, value);\n    entry.setLeftRecursive(isHeadOfLeftRecursion);\n    origPosInfo.memo[memoKey].traceEntry = entry;\n  }\n\n  origPosInfo.exit();\n\n  if (value) {\n    state.bindings.push(value);\n    return !isTopLevelApplication || this.entireInputWasConsumed(state);\n  } else {\n    return false;\n  }\n};\n\npexprs.Apply.prototype.evalOnce = function(expr, state) {\n  var inputStream = state.inputStream;\n  var origPos = inputStream.pos;\n  if (state.eval(expr)) {\n    var arity = expr.getArity();\n    var bindings = state.bindings.splice(state.bindings.length - arity, arity);\n    var ans = new Node(state.grammar, this.ruleName, bindings, inputStream.interval(origPos));\n    return ans;\n  } else {\n    return false;\n  }\n};\n\npexprs.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {\n  if (!newValue) {\n    return false;\n  }\n\n  var inputStream = state.inputStream;\n\n  while (true) {\n    lrMemoRec.pos = inputStream.pos;\n    lrMemoRec.value = newValue;\n    lrMemoRec.failuresAtRightmostPosition = state.rightmostFailures;\n    if (state.isTracing()) {\n      var children = state.trace[state.trace.length - 1].children.slice();\n      lrMemoRec.traceEntry = new Trace(state.inputStream, origPos, this, newValue, children);\n    }\n    inputStream.pos = origPos;\n    newValue = this.evalOnce(body, state);\n    if (inputStream.pos <= lrMemoRec.pos) {\n      break;\n    }\n  }\n  if (state.isTracing()) {\n    state.trace.pop();  // Drop last trace entry since `value` was unused.\n    lrMemoRec.traceEntry = null;\n  }\n  inputStream.pos = lrMemoRec.pos;\n  return lrMemoRec.value;\n};\n\npexprs.Apply.prototype.entireInputWasConsumed = function(state) {\n  if (this.isSyntactic()) {\n    state.skipSpaces();\n  }\n  if (!state.eval(pexprs.end)) {\n    return false;\n  }\n  state.bindings.pop();  // discard the binding that was added by `end` in the check above\n  return true;\n};\n\npexprs.UnicodeChar.prototype.eval = function(state) {\n  var origPos = state.skipSpacesIfInSyntacticContext();\n  var inputStream = state.inputStream;\n  var value = inputStream.next();\n  if (value === common.fail || !this.pattern.test(value)) {\n    state.processFailure(origPos, this);\n    return false;\n  } else {\n    var interval = inputStream.interval(origPos);\n    state.bindings.push(new TerminalNode(state.grammar, value, interval));\n    return true;\n  }\n};\n","deps":{"./fsets":"/Users/dubroy/dev/cdg/ohm/src/fsets.js","./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./nodes":"/Users/dubroy/dev/cdg/ohm/src/nodes.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js","./Trace":"/Users/dubroy/dev/cdg/ohm/src/Trace.js","./InputStream":"/Users/dubroy/dev/cdg/ohm/src/InputStream.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-eval.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-eval.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-getArity.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-getArity.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.getArity = common.abstract;\n\npexprs.any.getArity =\npexprs.end.getArity =\npexprs.Prim.prototype.getArity =\npexprs.Range.prototype.getArity =\npexprs.Param.prototype.getArity =\npexprs.Apply.prototype.getArity =\npexprs.UnicodeChar.prototype.getArity = function() {\n  return 1;\n};\n\npexprs.Alt.prototype.getArity = function() {\n  // This is ok b/c all terms must have the same arity -- this property is\n  // checked by the Grammar constructor.\n  return this.terms.length === 0 ? 0 : this.terms[0].getArity();\n};\n\npexprs.Seq.prototype.getArity = function() {\n  var arity = 0;\n  for (var idx = 0; idx < this.factors.length; idx++) {\n    arity += this.factors[idx].getArity();\n  }\n  return arity;\n};\n\npexprs.Iter.prototype.getArity = function() {\n  return this.expr.getArity();\n};\n\npexprs.Not.prototype.getArity = function() {\n  return 0;\n};\n\npexprs.Lookahead.prototype.getArity =\npexprs.Lex.prototype.getArity =\npexprs.Arr.prototype.getArity =\npexprs.Str.prototype.getArity = function() {\n  return this.expr.getArity();\n};\n\npexprs.Obj.prototype.getArity = function() {\n  var arity = this.isLenient ? 1 : 0;\n  for (var idx = 0; idx < this.properties.length; idx++) {\n    arity += this.properties[idx].pattern.getArity();\n  }\n  return arity;\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-getArity.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-getArity.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-introduceParams.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-introduceParams.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n// NOTE: the `introduceParams` method modifies the receiver in place.\n\npexprs.PExpr.prototype.introduceParams = common.abstract;\n\npexprs.any.introduceParams =\npexprs.end.introduceParams =\npexprs.Prim.prototype.introduceParams =\npexprs.Range.prototype.introduceParams =\npexprs.Param.prototype.introduceParams =\npexprs.UnicodeChar.prototype.introduceParams = function(formals) {\n  return this;\n};\n\npexprs.Alt.prototype.introduceParams = function(formals) {\n  this.terms.forEach(function(term, idx, terms) {\n    terms[idx] = term.introduceParams(formals);\n  });\n  return this;\n};\n\npexprs.Seq.prototype.introduceParams = function(formals) {\n  this.factors.forEach(function(factor, idx, factors) {\n    factors[idx] = factor.introduceParams(formals);\n  });\n  return this;\n};\n\npexprs.Iter.prototype.introduceParams =\npexprs.Not.prototype.introduceParams =\npexprs.Lookahead.prototype.introduceParams =\npexprs.Lex.prototype.introduceParams =\npexprs.Arr.prototype.introduceParams =\npexprs.Str.prototype.introduceParams = function(formals) {\n  this.expr = this.expr.introduceParams(formals);\n  return this;\n};\n\npexprs.Obj.prototype.introduceParams = function(formals) {\n  this.properties.forEach(function(property, idx) {\n    property.pattern = property.pattern.introduceParams(formals);\n  });\n  return this;\n};\n\npexprs.Apply.prototype.introduceParams = function(formals) {\n  var index = formals.indexOf(this.ruleName);\n  if (index >= 0) {\n    if (this.params.length > 0) {\n      throw new Error('FIXME: should catch this earlier');\n    }\n    return new pexprs.Param(index);\n  } else {\n    this.params.forEach(function(param, idx, params) {\n      params[idx] = param.introduceParams(formals);\n    });\n    return this;\n  }\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-introduceParams.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-introduceParams.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-isNullable.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-isNullable.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n// Returns `true` if this parsing expression may accept without consuming any input.\npexprs.PExpr.prototype.isNullable = function(grammar) {\n  return this._isNullable(grammar, Object.create(null));\n};\n\npexprs.PExpr.prototype._isNullable = common.abstract;\n\npexprs.any._isNullable =\npexprs.Range.prototype._isNullable =\npexprs.Param.prototype._isNullable =\npexprs.Plus.prototype._isNullable =\npexprs.Arr.prototype._isNullable =\npexprs.Obj.prototype._isNullable =\npexprs.UnicodeChar.prototype._isNullable = function(grammar, memo) {\n  return false;\n};\n\npexprs.end._isNullable = function(grammar, memo) {\n  return true;\n};\n\npexprs.Prim.prototype._isNullable = function(grammar, memo) {\n  if (typeof this.obj === 'string') {\n    // This is an over-simplification: it's only correct if the input is a string. If it's an array\n    // or an object, then the empty string parsing expression is not nullable.\n    return this.obj === '';\n  } else {\n    return false;\n  }\n};\n\npexprs.Alt.prototype._isNullable = function(grammar, memo) {\n  return this.terms.length === 0 ||\n      this.terms.some(function(term) { return term._isNullable(grammar, memo); });\n};\n\npexprs.Seq.prototype._isNullable = function(grammar, memo) {\n  return this.factors.every(function(factor) { return factor._isNullable(grammar, memo); });\n};\n\npexprs.Star.prototype._isNullable =\npexprs.Opt.prototype._isNullable =\npexprs.Not.prototype._isNullable =\npexprs.Lookahead.prototype._isNullable = function(grammar, memo) {\n  return true;\n};\n\npexprs.Lex.prototype._isNullable = function(grammar, memo) {\n  return this.expr._isNullable(grammar, memo);\n};\n\npexprs.Str.prototype._isNullable = function(grammar, memo) {\n  // This is also an over-simplification that is only correct when the input is a string.\n  return this.expr._isNullable(grammar, memo);\n};\n\npexprs.Apply.prototype._isNullable = function(grammar, memo) {\n  var key = this.toMemoKey();\n  if (!Object.prototype.hasOwnProperty.call(memo, key)) {\n    var body = grammar.ruleBodies[this.ruleName];\n    var inlined = body.substituteParams(this.params);\n    memo[key] = false;\n    memo[key] = inlined._isNullable(grammar, memo);\n  }\n  return memo[key];\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-isNullable.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-isNullable.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-outputRecipe.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-outputRecipe.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.outputRecipe = common.abstract;\n\npexprs.any.outputRecipe = function(sb, formals) {\n  throw new Error('should never output a recipe for `any` expression');\n};\n\npexprs.end.outputRecipe = function(sb, formals) {\n  throw new Error('should never output a recipe for `end` expression');\n};\n\npexprs.Prim.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.prim(');\n  sb.append(typeof this.obj === 'string' ? JSON.stringify(this.obj) : '' + this.obj);\n  sb.append(')');\n};\n\npexprs.Range.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.range(');\n  sb.append(JSON.stringify(this.from));\n  sb.append(', ');\n  sb.append(JSON.stringify(this.to));\n  sb.append(')');\n};\n\npexprs.Param.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.param(' + this.index + ')');\n};\n\npexprs.Alt.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.alt(');\n  for (var idx = 0; idx < this.terms.length; idx++) {\n    if (idx > 0) {\n      sb.append(', ');\n    }\n    this.terms[idx].outputRecipe(sb, formals);\n  }\n  sb.append(')');\n};\n\npexprs.Seq.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.seq(');\n  for (var idx = 0; idx < this.factors.length; idx++) {\n    if (idx > 0) {\n      sb.append(', ');\n    }\n    this.factors[idx].outputRecipe(sb, formals);\n  }\n  sb.append(')');\n};\n\npexprs.Star.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.star(');\n  this.expr.outputRecipe(sb, formals);\n  sb.append(')');\n};\n\npexprs.Plus.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.plus(');\n  this.expr.outputRecipe(sb, formals);\n  sb.append(')');\n};\n\npexprs.Opt.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.opt(');\n  this.expr.outputRecipe(sb, formals);\n  sb.append(')');\n};\n\npexprs.Not.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.not(');\n  this.expr.outputRecipe(sb, formals);\n  sb.append(')');\n};\n\npexprs.Lookahead.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.la(');\n  this.expr.outputRecipe(sb, formals);\n  sb.append(')');\n};\n\npexprs.Lex.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.lex(');\n  this.expr.outputRecipe(sb, formals);\n  sb.append(')');\n};\n\npexprs.Arr.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.arr(');\n  this.expr.outputRecipe(sb, formals);\n  sb.append(')');\n};\n\npexprs.Str.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.str(');\n  this.expr.outputRecipe(sb, formals);\n  sb.append(')');\n};\n\npexprs.Obj.prototype.outputRecipe = function(sb, formals) {\n  function outputPropertyRecipe(prop) {\n    sb.append('{name: ');\n    sb.append(JSON.stringify(prop.name));\n    sb.append(', pattern: ');\n    prop.pattern.outputRecipe(sb, formals);\n    sb.append('}');\n  }\n\n  sb.append('this.obj([');\n  for (var idx = 0; idx < this.properties.length; idx++) {\n    if (idx > 0) {\n      sb.append(', ');\n    }\n    outputPropertyRecipe(this.properties[idx]);\n  }\n  sb.append('], ');\n  sb.append(!!this.isLenient);\n  sb.append(')');\n};\n\npexprs.Apply.prototype.outputRecipe = function(sb, formals) {\n  sb.append('this.app(');\n  sb.append(JSON.stringify(this.ruleName));\n  if (this.ruleName.indexOf('_') >= 0 && formals.length > 0) {\n    var apps = formals.\n        map(function(formal) { return 'this.app(' + JSON.stringify(formal) + ')'; });\n    sb.append(', [' + apps.join(', ') + ']');\n  } else if (this.params.length > 0) {\n    sb.append(', [');\n    this.params.forEach(function(param, idx) {\n      if (idx > 0) {\n        sb.append(', ');\n      }\n      param.outputRecipe(sb, formals);\n    });\n    sb.append(']');\n  }\n  sb.append(')');\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-outputRecipe.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-outputRecipe.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-substituteParams.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-substituteParams.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.substituteParams = common.abstract;\n\npexprs.any.substituteParams =\npexprs.end.substituteParams =\npexprs.Prim.prototype.substituteParams =\npexprs.Range.prototype.substituteParams =\npexprs.Prim.prototype.substituteParams =\npexprs.UnicodeChar.prototype.substituteParams = function(actuals) {\n  return this;\n};\n\npexprs.Param.prototype.substituteParams = function(actuals) {\n  return actuals[this.index];\n};\n\npexprs.Alt.prototype.substituteParams = function(actuals) {\n  return new pexprs.Alt(\n      this.terms.map(function(term) { return term.substituteParams(actuals); }));\n};\n\npexprs.Seq.prototype.substituteParams = function(actuals) {\n  return new pexprs.Seq(\n      this.factors.map(function(factor) { return factor.substituteParams(actuals); }));\n};\n\npexprs.Iter.prototype.substituteParams =\npexprs.Not.prototype.substituteParams =\npexprs.Lookahead.prototype.substituteParams =\npexprs.Lex.prototype.substituteParams =\npexprs.Arr.prototype.substituteParams =\npexprs.Str.prototype.substituteParams = function(actuals) {\n  return new this.constructor(this.expr.substituteParams(actuals));\n};\n\npexprs.Obj.prototype.substituteParams = function(actuals) {\n  var properties = this.properties.map(function(property) {\n    return {\n      name: property.name,\n      pattern: property.pattern.substituteParams(actuals)\n    };\n  });\n  return new pexprs.Obj(properties, this.isLenient);\n};\n\npexprs.Apply.prototype.substituteParams = function(actuals) {\n  if (this.params.length === 0) {\n    // Avoid making a copy of this application, as an optimization\n    return this;\n  } else {\n    var params = this.params.map(function(param) { return param.substituteParams(actuals); });\n    return new pexprs.Apply(this.ruleName, params);\n  }\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-substituteParams.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-substituteParams.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-toDisplayString.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toDisplayString.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n// Returns a string representing the PExpr, for use as a UI label, etc.\npexprs.PExpr.prototype.toDisplayString = common.abstract;\n\npexprs.Alt.prototype.toDisplayString =\npexprs.Seq.prototype.toDisplayString =\npexprs.Iter.prototype.toDisplayString =\npexprs.Not.prototype.toDisplayString =\npexprs.Lookahead.prototype.toDisplayString =\npexprs.Lex.prototype.toDisplayString =\npexprs.Arr.prototype.toDisplayString =\npexprs.Str.prototype.toDisplayString =\npexprs.Obj.prototype.toDisplayString = function() {\n  if (this.interval) {\n    return this.interval.trimmed().contents;\n  }\n  return '[' + this.constructor.name + ']';\n};\n\npexprs.any.toDisplayString = function() {\n  return 'any';\n};\n\npexprs.end.toDisplayString = function() {\n  return 'end';\n};\n\npexprs.Prim.prototype.toDisplayString = function() {\n  return JSON.stringify(this.obj);\n};\n\npexprs.Range.prototype.toDisplayString = function() {\n  return JSON.stringify(this.from) + '..' + JSON.stringify(this.to);\n};\n\npexprs.Param.prototype.toDisplayString = function() {\n  return '#' + this.index;\n};\n\npexprs.Apply.prototype.toDisplayString = function() {\n  return this.toString();\n};\n\npexprs.UnicodeChar.prototype.toDisplayString = function() {\n  return 'Unicode {' + this.category + '} character';\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toDisplayString.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-toDisplayString.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-toFailure.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toFailure.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar Failure = require('./Failure');\nvar common = require('./common');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs.PExpr.prototype.toFailure = common.abstract;\n\npexprs.any.toFailure = function(grammar) {\n  return new Failure('any object', 'description');\n};\n\npexprs.end.toFailure = function(grammar) {\n  return new Failure('end of input', 'description');\n};\n\npexprs.Prim.prototype.toFailure = function(grammar) {\n  return typeof this.obj === 'string' ?\n    new Failure(this.obj, 'string') :\n    new Failure(JSON.stringify(this.obj), 'code');\n};\n\npexprs.Range.prototype.toFailure = function(grammar) {\n  // TODO: come up with something better\n  return new Failure(JSON.stringify(this.from) + '..' + JSON.stringify(this.to), 'code');\n};\n\npexprs.Not.prototype.toFailure = function(grammar) {\n  var description = this.expr === pexprs.any ?\n      'nothing' :\n      'not ' + this.expr.toFailure(grammar);\n  return new Failure(description, 'description');\n};\n\n// TODO: think about Arr, Str, and Obj\n\npexprs.Apply.prototype.toFailure = function(grammar) {\n  var description = grammar.ruleDescriptions[this.ruleName];\n  if (!description) {\n    var article = (/^[aeiouAEIOU]/.test(this.ruleName) ? 'an' : 'a');\n    description = article + ' ' + this.ruleName;\n  }\n  return new Failure(description, 'description');\n};\n\npexprs.UnicodeChar.prototype.toFailure = function(grammar) {\n  return new Failure(this.toDisplayString(), 'description');\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js","./Failure":"/Users/dubroy/dev/cdg/ohm/src/Failure.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toFailure.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-toFailure.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs-toString.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toString.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  e1.toString() === e2.toString() ==> e1 and e2 are semantically equivalent.\n  Note that this is not an iff (<==>): e.g.,\n  (~\"b\" \"a\").toString() !== (\"a\").toString(), even though\n  ~\"b\" \"a\" and \"a\" are interchangeable in any grammar,\n  both in terms of the languages they accept and their arities.\n*/\npexprs.PExpr.prototype.toString = common.abstract;\n\npexprs.any.toString = function() {\n  return 'any';\n};\n\npexprs.end.toString = function() {\n  return 'end';\n};\n\npexprs.Prim.prototype.toString = function() {\n  return JSON.stringify(this.obj);\n};\n\npexprs.Range.prototype.toString = function() {\n  return JSON.stringify(this.from) + '..' + JSON.stringify(this.to);\n};\n\npexprs.Param.prototype.toString = function() {\n  return '$' + this.index;\n};\n\npexprs.Lex.prototype.toString = function() {\n  return '#(' + this.expr.toString() + ')';\n};\n\npexprs.Alt.prototype.toString = function() {\n  return this.terms.length === 1 ?\n    this.terms[0].toString() :\n    '(' + this.terms.map(function(term) { return term.toString(); }).join(' | ') + ')';\n};\n\npexprs.Seq.prototype.toString = function() {\n  return this.factors.length === 1 ?\n    this.factors[0].toString() :\n    '(' + this.factors.map(function(factor) { return factor.toString(); }).join(' ') + ')';\n};\n\npexprs.Iter.prototype.toString = function() {\n  return this.expr + this.operator;\n};\n\npexprs.Not.prototype.toString = function() {\n  return '~' + this.expr;\n};\n\npexprs.Lookahead.prototype.toString = function() {\n  return '&' + this.expr;\n};\n\npexprs.Arr.prototype.toString = function() {\n  return '[' + this.expr.toString() + ']';\n};\n\npexprs.Str.prototype.toString = function() {\n  return '``' + this.expr.toString() + \"''\";\n};\n\npexprs.Obj.prototype.toString = function() {\n  var parts = ['{'];\n\n  var first = true;\n  function emit(part) {\n    if (first) {\n      first = false;\n    } else {\n      parts.push(', ');\n    }\n    parts.push(part);\n  }\n\n  this.properties.forEach(function(property) {\n    emit(JSON.stringify(property.name) + ': ' + property.pattern.toString());\n  });\n  if (this.isLenient) {\n    emit('...');\n  }\n\n  parts.push('}');\n  return parts.join('');\n};\n\npexprs.Apply.prototype.toString = function() {\n  if (this.params.length > 0) {\n    var ps = this.params.map(function(param) { return param.toString(); });\n    return this.ruleName + '<' + ps.join(',') + '>';\n  } else {\n    return this.ruleName;\n  }\n};\n\npexprs.UnicodeChar.prototype.toString = function() {\n  return '\\\\p{' + this.category + '}';\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toString.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs-toString.js"},"/Users/dubroy/dev/cdg/ohm/src/pexprs.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar UnicodeCategories = require('../third_party/UnicodeCategories');\nvar common = require('./common');\nvar errors = require('./errors');\nvar inherits = require('inherits');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// General stuff\n\nfunction PExpr() {\n  throw new Error(\"PExpr cannot be instantiated -- it's abstract\");\n}\n\nPExpr.prototype.withInterval = function(interval) {\n  if (interval) {\n    this.interval = interval.trimmed();\n  }\n  return this;\n};\n\n// Any\n\nvar any = Object.create(PExpr.prototype);\n\n// End\n\nvar end = Object.create(PExpr.prototype);\n\n// Primitives\n\nfunction Prim(obj) {\n  this.obj = obj;\n}\ninherits(Prim, PExpr);\n\n// Ranges\n\nfunction Range(from, to) {\n  this.from = from;\n  this.to = to;\n}\ninherits(Range, PExpr);\n\n// Parameters\n\nfunction Param(index) {\n  this.index = index;\n}\ninherits(Param, PExpr);\n\n// Alternation\n\nfunction Alt(terms) {\n  this.terms = terms;\n}\ninherits(Alt, PExpr);\n\n// Extend is an implementation detail of rule extension\n\nfunction Extend(superGrammar, name, body) {\n  this.superGrammar = superGrammar;\n  this.name = name;\n  this.body = body;\n  var origBody = superGrammar.ruleBodies[name];\n  this.terms = [body, origBody];\n}\ninherits(Extend, Alt);\n\n// Sequences\n\nfunction Seq(factors) {\n  this.factors = factors;\n}\ninherits(Seq, PExpr);\n\n// Iterators and optionals\n\nfunction Iter(expr) {\n  this.expr = expr;\n}\ninherits(Iter, PExpr);\n\nfunction Star(expr) {\n  this.expr = expr;\n}\ninherits(Star, Iter);\n\nfunction Plus(expr) {\n  this.expr = expr;\n}\ninherits(Plus, Iter);\n\nfunction Opt(expr) {\n  this.expr = expr;\n}\ninherits(Opt, Iter);\n\nStar.prototype.operator = '*';\nPlus.prototype.operator = '+';\nOpt.prototype.operator = '?';\n\nStar.prototype.minNumMatches = 0;\nPlus.prototype.minNumMatches = 1;\nOpt.prototype.minNumMatches = 0;\n\nStar.prototype.maxNumMatches = Number.POSITIVE_INFINITY;\nPlus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;\nOpt.prototype.maxNumMatches = 1;\n\n// Predicates\n\nfunction Not(expr) {\n  this.expr = expr;\n}\ninherits(Not, PExpr);\n\nfunction Lookahead(expr) {\n  this.expr = expr;\n}\ninherits(Lookahead, PExpr);\n\n// \"Lexification\"\n\nfunction Lex(expr) {\n  this.expr = expr;\n}\ninherits(Lex, PExpr);\n\n// Array decomposition\n\nfunction Arr(expr) {\n  this.expr = expr;\n}\ninherits(Arr, PExpr);\n\n// String decomposition\n\nfunction Str(expr) {\n  this.expr = expr;\n}\ninherits(Str, PExpr);\n\n// Object decomposition\n\nfunction Obj(properties, isLenient) {\n  var names = properties.map(function(property) { return property.name; });\n  var duplicates = common.getDuplicates(names);\n  if (duplicates.length > 0) {\n    throw errors.duplicatePropertyNames(duplicates);\n  } else {\n    this.properties = properties;\n    this.isLenient = isLenient;\n  }\n}\ninherits(Obj, PExpr);\n\n// Rule application\n\nfunction Apply(ruleName, optParams) {\n  this.ruleName = ruleName;\n  this.params = optParams || [];\n}\ninherits(Apply, PExpr);\n\nApply.prototype.isSyntactic = function() {\n  return common.isSyntactic(this.ruleName);\n};\n\n// This method just caches the result of `this.toString()` in a non-enumerable property.\nApply.prototype.toMemoKey = function() {\n  if (!this._memoKey) {\n    Object.defineProperty(this, '_memoKey', {value: this.toString()});\n  }\n  return this._memoKey;\n};\n\n// Unicode character\n\nfunction UnicodeChar(category) {\n  this.category = category;\n  this.pattern = UnicodeCategories[category];\n}\ninherits(UnicodeChar, PExpr);\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nexports.PExpr = PExpr;\nexports.any = any;\nexports.end = end;\nexports.Prim = Prim;\nexports.Range = Range;\nexports.Param = Param;\nexports.Alt = Alt;\nexports.Extend = Extend;\nexports.Seq = Seq;\nexports.Iter = Iter;\nexports.Star = Star;\nexports.Plus = Plus;\nexports.Opt = Opt;\nexports.Not = Not;\nexports.Lookahead = Lookahead;\nexports.Lex = Lex;\nexports.Arr = Arr;\nexports.Str = Str;\nexports.Obj = Obj;\nexports.Apply = Apply;\nexports.UnicodeChar = UnicodeChar;\n\n// --------------------------------------------------------------------\n// Extensions\n// --------------------------------------------------------------------\n\nrequire('./pexprs-assertAllApplicationsAreValid');\nrequire('./pexprs-assertChoicesHaveUniformArity');\nrequire('./pexprs-assertIteratedExprsAreNotNullable');\nrequire('./pexprs-check');\nrequire('./pexprs-eval');\nrequire('./pexprs-getArity');\nrequire('./pexprs-outputRecipe');\nrequire('./pexprs-introduceParams');\nrequire('./pexprs-isNullable');\nrequire('./pexprs-substituteParams');\nrequire('./pexprs-toDisplayString');\nrequire('./pexprs-toFailure');\nrequire('./pexprs-toString');\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./errors":"/Users/dubroy/dev/cdg/ohm/src/errors.js","./pexprs-assertAllApplicationsAreValid":"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertAllApplicationsAreValid.js","./pexprs-assertChoicesHaveUniformArity":"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertChoicesHaveUniformArity.js","./pexprs-assertIteratedExprsAreNotNullable":"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertIteratedExprsAreNotNullable.js","./pexprs-getArity":"/Users/dubroy/dev/cdg/ohm/src/pexprs-getArity.js","./pexprs-outputRecipe":"/Users/dubroy/dev/cdg/ohm/src/pexprs-outputRecipe.js","./pexprs-introduceParams":"/Users/dubroy/dev/cdg/ohm/src/pexprs-introduceParams.js","./pexprs-isNullable":"/Users/dubroy/dev/cdg/ohm/src/pexprs-isNullable.js","./pexprs-substituteParams":"/Users/dubroy/dev/cdg/ohm/src/pexprs-substituteParams.js","./pexprs-toDisplayString":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toDisplayString.js","./pexprs-toString":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toString.js","./pexprs-toFailure":"/Users/dubroy/dev/cdg/ohm/src/pexprs-toFailure.js","./pexprs-eval":"/Users/dubroy/dev/cdg/ohm/src/pexprs-eval.js","./pexprs-check":"/Users/dubroy/dev/cdg/ohm/src/pexprs-check.js","../third_party/UnicodeCategories":"/Users/dubroy/dev/cdg/ohm/third_party/UnicodeCategories.js","inherits":"/Users/dubroy/dev/cdg/ohm/node_modules/inherits/inherits_browser.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js","sourceRoot":"file://localhost","sourceFile":"src/pexprs.js"},"/Users/dubroy/dev/cdg/ohm/src/util.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/util.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar common = require('./common');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Given an array of numbers `arr`, return an array of the numbers as strings,\n// right-justified and padded to the same length.\nfunction padNumbersToEqualLength(arr) {\n  var maxLen = 0;\n  var strings = arr.map(function(n) {\n    var str = n.toString();\n    maxLen = Math.max(maxLen, str.length);\n    return str;\n  });\n  return strings.map(function(s) { return common.padLeft(s, maxLen); });\n}\n\n// Produce a new string that would be the result of copying the contents\n// of the string `src` onto `dest` at offset `offest`.\nfunction strcpy(dest, src, offset) {\n  var origDestLen = dest.length;\n  var start = dest.slice(0, offset);\n  var end = dest.slice(offset + src.length);\n  return (start + src + end).substr(0, origDestLen);\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\n// Return an object with the line and column information for the given\n// offset in `str`.\nexports.getLineAndColumn = function(str, offset) {\n  var lineNum = 1;\n  var colNum = 1;\n\n  var currOffset = 0;\n  var lineStartOffset = 0;\n\n  var nextLine = null;\n  var prevLine = null;\n  var prevLineStartOffset = -1;\n\n  while (currOffset < offset) {\n    var c = str.charAt(currOffset++);\n    if (c === '\\n') {\n      lineNum++;\n      colNum = 1;\n      prevLineStartOffset = lineStartOffset;\n      lineStartOffset = currOffset;\n    } else if (c !== '\\r') {\n      colNum++;\n    }\n  }\n\n  // Find the end of the target line.\n  var lineEndOffset = str.indexOf('\\n', lineStartOffset);\n  if (lineEndOffset === -1) {\n    lineEndOffset = str.length;\n  } else {\n    // Get the next line.\n    var nextLineEndOffset = str.indexOf('\\n', lineEndOffset + 1);\n    nextLine = nextLineEndOffset === -1 ? str.slice(lineEndOffset)\n                                        : str.slice(lineEndOffset, nextLineEndOffset);\n    // Strip leading and trailing EOL char(s).\n    nextLine = nextLine.replace(/^\\r?\\n/, '').replace(/\\r$/, '');\n  }\n\n  // Get the previous line.\n  if (prevLineStartOffset >= 0) {\n    prevLine = str.slice(prevLineStartOffset, lineStartOffset)\n                  .replace(/\\r?\\n$/, '');  // Strip trailing EOL char(s).\n  }\n\n  // Get the target line, stripping a trailing carriage return if necessary.\n  var line = str.slice(lineStartOffset, lineEndOffset).replace(/\\r$/, '');\n\n  return {\n    lineNum: lineNum,\n    colNum: colNum,\n    line: line,\n    prevLine: prevLine,\n    nextLine: nextLine\n  };\n};\n\n// Return a nicely-formatted string describing the line and column for the\n// given offset in `str`.\nexports.getLineAndColumnMessage = function(str, offset /* ...ranges */) {\n  var repeatStr = common.repeatStr;\n\n  var lineAndCol = exports.getLineAndColumn(str, offset);\n  var sb = new common.StringBuffer();\n  sb.append('Line ' + lineAndCol.lineNum + ', col ' + lineAndCol.colNum + ':\\n');\n\n  // An array of the previous, current, and next line numbers as strings of equal length.\n  var lineNumbers = padNumbersToEqualLength([\n      lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,\n      lineAndCol.lineNum,\n      lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1\n  ]);\n\n  // Helper for appending formatting input lines to the buffer.\n  function appendLine(num, content, prefix) {\n    sb.append(prefix + lineNumbers[num] + ' | ' + content + '\\n');\n  }\n\n  // Include the previous line for context if possible.\n  if (lineAndCol.prevLine != null) {\n    appendLine(0, lineAndCol.prevLine, '  ');\n  }\n  // Line that the error occurred on.\n  appendLine(1, lineAndCol.line, '> ');\n\n  // Build up the line that points to the offset and possible indicates one or more ranges.\n  // Start with a blank line, and indicate each range by overlaying a string of `~` chars.\n  var lineLen = lineAndCol.line.length;\n  var indicationLine = repeatStr(' ', lineLen + 1);\n  var ranges = Array.prototype.slice.call(arguments, 2);\n  for (var i = 0; i < ranges.length; ++i) {\n    var startIdx = ranges[i][0];\n    var endIdx = ranges[i][1];\n    common.assert(startIdx >= 0 && startIdx <= endIdx, 'range start must be >= 0 and <= end');\n\n    var lineStartOffset = offset - lineAndCol.colNum + 1;\n    startIdx = Math.max(0, startIdx - lineStartOffset);\n    endIdx = Math.min(endIdx - lineStartOffset, lineLen);\n\n    indicationLine = strcpy(indicationLine, repeatStr('~', endIdx - startIdx), startIdx);\n  }\n  var gutterWidth = 2 + lineNumbers[1].length + 3;\n  sb.append(repeatStr(' ', gutterWidth));\n  indicationLine = strcpy(indicationLine, '^', lineAndCol.colNum - 1);\n  sb.append(indicationLine.replace(/ +$/, '') + '\\n');\n\n  // Include the next line for context if possible.\n  if (lineAndCol.nextLine != null) {\n    appendLine(2, lineAndCol.nextLine, '  ');\n  }\n  return sb.contents();\n};\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/util.js","sourceRoot":"file://localhost","sourceFile":"src/util.js"},"/Users/dubroy/dev/cdg/ohm/third_party/UnicodeCategories.js":{"id":"/Users/dubroy/dev/cdg/ohm/third_party/UnicodeCategories.js","source":"// Based on https://github.com/tvcutsem/es-lab/blob/master/src/parser/unicode.js.\n// These are just categories that are used in ES5.\n// The full list of Unicode categories is here: http://www.fileformat.info/info/unicode/category/index.htm.\nmodule.exports = {\n  // Letters\n  Lu: /[\\u0041-\\u005A]|[\\u00C0-\\u00D6]|[\\u00D8-\\u00DE]|[\\u0100-\\u0100]|[\\u0102-\\u0102]|[\\u0104-\\u0104]|[\\u0106-\\u0106]|[\\u0108-\\u0108]|[\\u010A-\\u010A]|[\\u010C-\\u010C]|[\\u010E-\\u010E]|[\\u0110-\\u0110]|[\\u0112-\\u0112]|[\\u0114-\\u0114]|[\\u0116-\\u0116]|[\\u0118-\\u0118]|[\\u011A-\\u011A]|[\\u011C-\\u011C]|[\\u011E-\\u011E]|[\\u0120-\\u0120]|[\\u0122-\\u0122]|[\\u0124-\\u0124]|[\\u0126-\\u0126]|[\\u0128-\\u0128]|[\\u012A-\\u012A]|[\\u012C-\\u012C]|[\\u012E-\\u012E]|[\\u0130-\\u0130]|[\\u0132-\\u0132]|[\\u0134-\\u0134]|[\\u0136-\\u0136]|[\\u0139-\\u0139]|[\\u013B-\\u013B]|[\\u013D-\\u013D]|[\\u013F-\\u013F]|[\\u0141-\\u0141]|[\\u0143-\\u0143]|[\\u0145-\\u0145]|[\\u0147-\\u0147]|[\\u014A-\\u014A]|[\\u014C-\\u014C]|[\\u014E-\\u014E]|[\\u0150-\\u0150]|[\\u0152-\\u0152]|[\\u0154-\\u0154]|[\\u0156-\\u0156]|[\\u0158-\\u0158]|[\\u015A-\\u015A]|[\\u015C-\\u015C]|[\\u015E-\\u015E]|[\\u0160-\\u0160]|[\\u0162-\\u0162]|[\\u0164-\\u0164]|[\\u0166-\\u0166]|[\\u0168-\\u0168]|[\\u016A-\\u016A]|[\\u016C-\\u016C]|[\\u016E-\\u016E]|[\\u0170-\\u0170]|[\\u0172-\\u0172]|[\\u0174-\\u0174]|[\\u0176-\\u0176]|[\\u0178-\\u0179]|[\\u017B-\\u017B]|[\\u017D-\\u017D]|[\\u0181-\\u0182]|[\\u0184-\\u0184]|[\\u0186-\\u0187]|[\\u0189-\\u018B]|[\\u018E-\\u0191]|[\\u0193-\\u0194]|[\\u0196-\\u0198]|[\\u019C-\\u019D]|[\\u019F-\\u01A0]|[\\u01A2-\\u01A2]|[\\u01A4-\\u01A4]|[\\u01A6-\\u01A7]|[\\u01A9-\\u01A9]|[\\u01AC-\\u01AC]|[\\u01AE-\\u01AF]|[\\u01B1-\\u01B3]|[\\u01B5-\\u01B5]|[\\u01B7-\\u01B8]|[\\u01BC-\\u01BC]|[\\u01C4-\\u01C4]|[\\u01C7-\\u01C7]|[\\u01CA-\\u01CA]|[\\u01CD-\\u01CD]|[\\u01CF-\\u01CF]|[\\u01D1-\\u01D1]|[\\u01D3-\\u01D3]|[\\u01D5-\\u01D5]|[\\u01D7-\\u01D7]|[\\u01D9-\\u01D9]|[\\u01DB-\\u01DB]|[\\u01DE-\\u01DE]|[\\u01E0-\\u01E0]|[\\u01E2-\\u01E2]|[\\u01E4-\\u01E4]|[\\u01E6-\\u01E6]|[\\u01E8-\\u01E8]|[\\u01EA-\\u01EA]|[\\u01EC-\\u01EC]|[\\u01EE-\\u01EE]|[\\u01F1-\\u01F1]|[\\u01F4-\\u01F4]|[\\u01FA-\\u01FA]|[\\u01FC-\\u01FC]|[\\u01FE-\\u01FE]|[\\u0200-\\u0200]|[\\u0202-\\u0202]|[\\u0204-\\u0204]|[\\u0206-\\u0206]|[\\u0208-\\u0208]|[\\u020A-\\u020A]|[\\u020C-\\u020C]|[\\u020E-\\u020E]|[\\u0210-\\u0210]|[\\u0212-\\u0212]|[\\u0214-\\u0214]|[\\u0216-\\u0216]|[\\u0386-\\u0386]|[\\u0388-\\u038A]|[\\u038C-\\u038C]|[\\u038E-\\u038F]|[\\u0391-\\u03A1]|[\\u03A3-\\u03AB]|[\\u03D2-\\u03D4]|[\\u03DA-\\u03DA]|[\\u03DC-\\u03DC]|[\\u03DE-\\u03DE]|[\\u03E0-\\u03E0]|[\\u03E2-\\u03E2]|[\\u03E4-\\u03E4]|[\\u03E6-\\u03E6]|[\\u03E8-\\u03E8]|[\\u03EA-\\u03EA]|[\\u03EC-\\u03EC]|[\\u03EE-\\u03EE]|[\\u0401-\\u040C]|[\\u040E-\\u042F]|[\\u0460-\\u0460]|[\\u0462-\\u0462]|[\\u0464-\\u0464]|[\\u0466-\\u0466]|[\\u0468-\\u0468]|[\\u046A-\\u046A]|[\\u046C-\\u046C]|[\\u046E-\\u046E]|[\\u0470-\\u0470]|[\\u0472-\\u0472]|[\\u0474-\\u0474]|[\\u0476-\\u0476]|[\\u0478-\\u0478]|[\\u047A-\\u047A]|[\\u047C-\\u047C]|[\\u047E-\\u047E]|[\\u0480-\\u0480]|[\\u0490-\\u0490]|[\\u0492-\\u0492]|[\\u0494-\\u0494]|[\\u0496-\\u0496]|[\\u0498-\\u0498]|[\\u049A-\\u049A]|[\\u049C-\\u049C]|[\\u049E-\\u049E]|[\\u04A0-\\u04A0]|[\\u04A2-\\u04A2]|[\\u04A4-\\u04A4]|[\\u04A6-\\u04A6]|[\\u04A8-\\u04A8]|[\\u04AA-\\u04AA]|[\\u04AC-\\u04AC]|[\\u04AE-\\u04AE]|[\\u04B0-\\u04B0]|[\\u04B2-\\u04B2]|[\\u04B4-\\u04B4]|[\\u04B6-\\u04B6]|[\\u04B8-\\u04B8]|[\\u04BA-\\u04BA]|[\\u04BC-\\u04BC]|[\\u04BE-\\u04BE]|[\\u04C1-\\u04C1]|[\\u04C3-\\u04C3]|[\\u04C7-\\u04C7]|[\\u04CB-\\u04CB]|[\\u04D0-\\u04D0]|[\\u04D2-\\u04D2]|[\\u04D4-\\u04D4]|[\\u04D6-\\u04D6]|[\\u04D8-\\u04D8]|[\\u04DA-\\u04DA]|[\\u04DC-\\u04DC]|[\\u04DE-\\u04DE]|[\\u04E0-\\u04E0]|[\\u04E2-\\u04E2]|[\\u04E4-\\u04E4]|[\\u04E6-\\u04E6]|[\\u04E8-\\u04E8]|[\\u04EA-\\u04EA]|[\\u04EE-\\u04EE]|[\\u04F0-\\u04F0]|[\\u04F2-\\u04F2]|[\\u04F4-\\u04F4]|[\\u04F8-\\u04F8]|[\\u0531-\\u0556]|[\\u10A0-\\u10C5]|[\\u1E00-\\u1E00]|[\\u1E02-\\u1E02]|[\\u1E04-\\u1E04]|[\\u1E06-\\u1E06]|[\\u1E08-\\u1E08]|[\\u1E0A-\\u1E0A]|[\\u1E0C-\\u1E0C]|[\\u1E0E-\\u1E0E]|[\\u1E10-\\u1E10]|[\\u1E12-\\u1E12]|[\\u1E14-\\u1E14]|[\\u1E16-\\u1E16]|[\\u1E18-\\u1E18]|[\\u1E1A-\\u1E1A]|[\\u1E1C-\\u1E1C]|[\\u1E1E-\\u1E1E]|[\\u1E20-\\u1E20]|[\\u1E22-\\u1E22]|[\\u1E24-\\u1E24]|[\\u1E26-\\u1E26]|[\\u1E28-\\u1E28]|[\\u1E2A-\\u1E2A]|[\\u1E2C-\\u1E2C]|[\\u1E2E-\\u1E2E]|[\\u1E30-\\u1E30]|[\\u1E32-\\u1E32]|[\\u1E34-\\u1E34]|[\\u1E36-\\u1E36]|[\\u1E38-\\u1E38]|[\\u1E3A-\\u1E3A]|[\\u1E3C-\\u1E3C]|[\\u1E3E-\\u1E3E]|[\\u1E40-\\u1E40]|[\\u1E42-\\u1E42]|[\\u1E44-\\u1E44]|[\\u1E46-\\u1E46]|[\\u1E48-\\u1E48]|[\\u1E4A-\\u1E4A]|[\\u1E4C-\\u1E4C]|[\\u1E4E-\\u1E4E]|[\\u1E50-\\u1E50]|[\\u1E52-\\u1E52]|[\\u1E54-\\u1E54]|[\\u1E56-\\u1E56]|[\\u1E58-\\u1E58]|[\\u1E5A-\\u1E5A]|[\\u1E5C-\\u1E5C]|[\\u1E5E-\\u1E5E]|[\\u1E60-\\u1E60]|[\\u1E62-\\u1E62]|[\\u1E64-\\u1E64]|[\\u1E66-\\u1E66]|[\\u1E68-\\u1E68]|[\\u1E6A-\\u1E6A]|[\\u1E6C-\\u1E6C]|[\\u1E6E-\\u1E6E]|[\\u1E70-\\u1E70]|[\\u1E72-\\u1E72]|[\\u1E74-\\u1E74]|[\\u1E76-\\u1E76]|[\\u1E78-\\u1E78]|[\\u1E7A-\\u1E7A]|[\\u1E7C-\\u1E7C]|[\\u1E7E-\\u1E7E]|[\\u1E80-\\u1E80]|[\\u1E82-\\u1E82]|[\\u1E84-\\u1E84]|[\\u1E86-\\u1E86]|[\\u1E88-\\u1E88]|[\\u1E8A-\\u1E8A]|[\\u1E8C-\\u1E8C]|[\\u1E8E-\\u1E8E]|[\\u1E90-\\u1E90]|[\\u1E92-\\u1E92]|[\\u1E94-\\u1E94]|[\\u1EA0-\\u1EA0]|[\\u1EA2-\\u1EA2]|[\\u1EA4-\\u1EA4]|[\\u1EA6-\\u1EA6]|[\\u1EA8-\\u1EA8]|[\\u1EAA-\\u1EAA]|[\\u1EAC-\\u1EAC]|[\\u1EAE-\\u1EAE]|[\\u1EB0-\\u1EB0]|[\\u1EB2-\\u1EB2]|[\\u1EB4-\\u1EB4]|[\\u1EB6-\\u1EB6]|[\\u1EB8-\\u1EB8]|[\\u1EBA-\\u1EBA]|[\\u1EBC-\\u1EBC]|[\\u1EBE-\\u1EBE]|[\\u1EC0-\\u1EC0]|[\\u1EC2-\\u1EC2]|[\\u1EC4-\\u1EC4]|[\\u1EC6-\\u1EC6]|[\\u1EC8-\\u1EC8]|[\\u1ECA-\\u1ECA]|[\\u1ECC-\\u1ECC]|[\\u1ECE-\\u1ECE]|[\\u1ED0-\\u1ED0]|[\\u1ED2-\\u1ED2]|[\\u1ED4-\\u1ED4]|[\\u1ED6-\\u1ED6]|[\\u1ED8-\\u1ED8]|[\\u1EDA-\\u1EDA]|[\\u1EDC-\\u1EDC]|[\\u1EDE-\\u1EDE]|[\\u1EE0-\\u1EE0]|[\\u1EE2-\\u1EE2]|[\\u1EE4-\\u1EE4]|[\\u1EE6-\\u1EE6]|[\\u1EE8-\\u1EE8]|[\\u1EEA-\\u1EEA]|[\\u1EEC-\\u1EEC]|[\\u1EEE-\\u1EEE]|[\\u1EF0-\\u1EF0]|[\\u1EF2-\\u1EF2]|[\\u1EF4-\\u1EF4]|[\\u1EF6-\\u1EF6]|[\\u1EF8-\\u1EF8]|[\\u1F08-\\u1F0F]|[\\u1F18-\\u1F1D]|[\\u1F28-\\u1F2F]|[\\u1F38-\\u1F3F]|[\\u1F48-\\u1F4D]|[\\u1F59-\\u1F59]|[\\u1F5B-\\u1F5B]|[\\u1F5D-\\u1F5D]|[\\u1F5F-\\u1F5F]|[\\u1F68-\\u1F6F]|[\\u1F88-\\u1F8F]|[\\u1F98-\\u1F9F]|[\\u1FA8-\\u1FAF]|[\\u1FB8-\\u1FBC]|[\\u1FC8-\\u1FCC]|[\\u1FD8-\\u1FDB]|[\\u1FE8-\\u1FEC]|[\\u1FF8-\\u1FFC]|[\\u2102-\\u2102]|[\\u2107-\\u2107]|[\\u210B-\\u210D]|[\\u2110-\\u2112]|[\\u2115-\\u2115]|[\\u2119-\\u211D]|[\\u2124-\\u2124]|[\\u2126-\\u2126]|[\\u2128-\\u2128]|[\\u212A-\\u212D]|[\\u2130-\\u2131]|[\\u2133-\\u2133]|[\\uFF21-\\uFF3A]/,\n  Ll: /[\\u0061-\\u007A]|[\\u00AA-\\u00AA]|[\\u00B5-\\u00B5]|[\\u00BA-\\u00BA]|[\\u00DF-\\u00F6]|[\\u00F8-\\u00FF]|[\\u0101-\\u0101]|[\\u0103-\\u0103]|[\\u0105-\\u0105]|[\\u0107-\\u0107]|[\\u0109-\\u0109]|[\\u010B-\\u010B]|[\\u010D-\\u010D]|[\\u010F-\\u010F]|[\\u0111-\\u0111]|[\\u0113-\\u0113]|[\\u0115-\\u0115]|[\\u0117-\\u0117]|[\\u0119-\\u0119]|[\\u011B-\\u011B]|[\\u011D-\\u011D]|[\\u011F-\\u011F]|[\\u0121-\\u0121]|[\\u0123-\\u0123]|[\\u0125-\\u0125]|[\\u0127-\\u0127]|[\\u0129-\\u0129]|[\\u012B-\\u012B]|[\\u012D-\\u012D]|[\\u012F-\\u012F]|[\\u0131-\\u0131]|[\\u0133-\\u0133]|[\\u0135-\\u0135]|[\\u0137-\\u0138]|[\\u013A-\\u013A]|[\\u013C-\\u013C]|[\\u013E-\\u013E]|[\\u0140-\\u0140]|[\\u0142-\\u0142]|[\\u0144-\\u0144]|[\\u0146-\\u0146]|[\\u0148-\\u0149]|[\\u014B-\\u014B]|[\\u014D-\\u014D]|[\\u014F-\\u014F]|[\\u0151-\\u0151]|[\\u0153-\\u0153]|[\\u0155-\\u0155]|[\\u0157-\\u0157]|[\\u0159-\\u0159]|[\\u015B-\\u015B]|[\\u015D-\\u015D]|[\\u015F-\\u015F]|[\\u0161-\\u0161]|[\\u0163-\\u0163]|[\\u0165-\\u0165]|[\\u0167-\\u0167]|[\\u0169-\\u0169]|[\\u016B-\\u016B]|[\\u016D-\\u016D]|[\\u016F-\\u016F]|[\\u0171-\\u0171]|[\\u0173-\\u0173]|[\\u0175-\\u0175]|[\\u0177-\\u0177]|[\\u017A-\\u017A]|[\\u017C-\\u017C]|[\\u017E-\\u0180]|[\\u0183-\\u0183]|[\\u0185-\\u0185]|[\\u0188-\\u0188]|[\\u018C-\\u018D]|[\\u0192-\\u0192]|[\\u0195-\\u0195]|[\\u0199-\\u019B]|[\\u019E-\\u019E]|[\\u01A1-\\u01A1]|[\\u01A3-\\u01A3]|[\\u01A5-\\u01A5]|[\\u01A8-\\u01A8]|[\\u01AB-\\u01AB]|[\\u01AD-\\u01AD]|[\\u01B0-\\u01B0]|[\\u01B4-\\u01B4]|[\\u01B6-\\u01B6]|[\\u01B9-\\u01BA]|[\\u01BD-\\u01BD]|[\\u01C6-\\u01C6]|[\\u01C9-\\u01C9]|[\\u01CC-\\u01CC]|[\\u01CE-\\u01CE]|[\\u01D0-\\u01D0]|[\\u01D2-\\u01D2]|[\\u01D4-\\u01D4]|[\\u01D6-\\u01D6]|[\\u01D8-\\u01D8]|[\\u01DA-\\u01DA]|[\\u01DC-\\u01DD]|[\\u01DF-\\u01DF]|[\\u01E1-\\u01E1]|[\\u01E3-\\u01E3]|[\\u01E5-\\u01E5]|[\\u01E7-\\u01E7]|[\\u01E9-\\u01E9]|[\\u01EB-\\u01EB]|[\\u01ED-\\u01ED]|[\\u01EF-\\u01F0]|[\\u01F3-\\u01F3]|[\\u01F5-\\u01F5]|[\\u01FB-\\u01FB]|[\\u01FD-\\u01FD]|[\\u01FF-\\u01FF]|[\\u0201-\\u0201]|[\\u0203-\\u0203]|[\\u0205-\\u0205]|[\\u0207-\\u0207]|[\\u0209-\\u0209]|[\\u020B-\\u020B]|[\\u020D-\\u020D]|[\\u020F-\\u020F]|[\\u0211-\\u0211]|[\\u0213-\\u0213]|[\\u0215-\\u0215]|[\\u0217-\\u0217]|[\\u0250-\\u02A8]|[\\u0390-\\u0390]|[\\u03AC-\\u03CE]|[\\u03D0-\\u03D1]|[\\u03D5-\\u03D6]|[\\u03E3-\\u03E3]|[\\u03E5-\\u03E5]|[\\u03E7-\\u03E7]|[\\u03E9-\\u03E9]|[\\u03EB-\\u03EB]|[\\u03ED-\\u03ED]|[\\u03EF-\\u03F2]|[\\u0430-\\u044F]|[\\u0451-\\u045C]|[\\u045E-\\u045F]|[\\u0461-\\u0461]|[\\u0463-\\u0463]|[\\u0465-\\u0465]|[\\u0467-\\u0467]|[\\u0469-\\u0469]|[\\u046B-\\u046B]|[\\u046D-\\u046D]|[\\u046F-\\u046F]|[\\u0471-\\u0471]|[\\u0473-\\u0473]|[\\u0475-\\u0475]|[\\u0477-\\u0477]|[\\u0479-\\u0479]|[\\u047B-\\u047B]|[\\u047D-\\u047D]|[\\u047F-\\u047F]|[\\u0481-\\u0481]|[\\u0491-\\u0491]|[\\u0493-\\u0493]|[\\u0495-\\u0495]|[\\u0497-\\u0497]|[\\u0499-\\u0499]|[\\u049B-\\u049B]|[\\u049D-\\u049D]|[\\u049F-\\u049F]|[\\u04A1-\\u04A1]|[\\u04A3-\\u04A3]|[\\u04A5-\\u04A5]|[\\u04A7-\\u04A7]|[\\u04A9-\\u04A9]|[\\u04AB-\\u04AB]|[\\u04AD-\\u04AD]|[\\u04AF-\\u04AF]|[\\u04B1-\\u04B1]|[\\u04B3-\\u04B3]|[\\u04B5-\\u04B5]|[\\u04B7-\\u04B7]|[\\u04B9-\\u04B9]|[\\u04BB-\\u04BB]|[\\u04BD-\\u04BD]|[\\u04BF-\\u04BF]|[\\u04C2-\\u04C2]|[\\u04C4-\\u04C4]|[\\u04C8-\\u04C8]|[\\u04CC-\\u04CC]|[\\u04D1-\\u04D1]|[\\u04D3-\\u04D3]|[\\u04D5-\\u04D5]|[\\u04D7-\\u04D7]|[\\u04D9-\\u04D9]|[\\u04DB-\\u04DB]|[\\u04DD-\\u04DD]|[\\u04DF-\\u04DF]|[\\u04E1-\\u04E1]|[\\u04E3-\\u04E3]|[\\u04E5-\\u04E5]|[\\u04E7-\\u04E7]|[\\u04E9-\\u04E9]|[\\u04EB-\\u04EB]|[\\u04EF-\\u04EF]|[\\u04F1-\\u04F1]|[\\u04F3-\\u04F3]|[\\u04F5-\\u04F5]|[\\u04F9-\\u04F9]|[\\u0561-\\u0587]|[\\u10D0-\\u10F6]|[\\u1E01-\\u1E01]|[\\u1E03-\\u1E03]|[\\u1E05-\\u1E05]|[\\u1E07-\\u1E07]|[\\u1E09-\\u1E09]|[\\u1E0B-\\u1E0B]|[\\u1E0D-\\u1E0D]|[\\u1E0F-\\u1E0F]|[\\u1E11-\\u1E11]|[\\u1E13-\\u1E13]|[\\u1E15-\\u1E15]|[\\u1E17-\\u1E17]|[\\u1E19-\\u1E19]|[\\u1E1B-\\u1E1B]|[\\u1E1D-\\u1E1D]|[\\u1E1F-\\u1E1F]|[\\u1E21-\\u1E21]|[\\u1E23-\\u1E23]|[\\u1E25-\\u1E25]|[\\u1E27-\\u1E27]|[\\u1E29-\\u1E29]|[\\u1E2B-\\u1E2B]|[\\u1E2D-\\u1E2D]|[\\u1E2F-\\u1E2F]|[\\u1E31-\\u1E31]|[\\u1E33-\\u1E33]|[\\u1E35-\\u1E35]|[\\u1E37-\\u1E37]|[\\u1E39-\\u1E39]|[\\u1E3B-\\u1E3B]|[\\u1E3D-\\u1E3D]|[\\u1E3F-\\u1E3F]|[\\u1E41-\\u1E41]|[\\u1E43-\\u1E43]|[\\u1E45-\\u1E45]|[\\u1E47-\\u1E47]|[\\u1E49-\\u1E49]|[\\u1E4B-\\u1E4B]|[\\u1E4D-\\u1E4D]|[\\u1E4F-\\u1E4F]|[\\u1E51-\\u1E51]|[\\u1E53-\\u1E53]|[\\u1E55-\\u1E55]|[\\u1E57-\\u1E57]|[\\u1E59-\\u1E59]|[\\u1E5B-\\u1E5B]|[\\u1E5D-\\u1E5D]|[\\u1E5F-\\u1E5F]|[\\u1E61-\\u1E61]|[\\u1E63-\\u1E63]|[\\u1E65-\\u1E65]|[\\u1E67-\\u1E67]|[\\u1E69-\\u1E69]|[\\u1E6B-\\u1E6B]|[\\u1E6D-\\u1E6D]|[\\u1E6F-\\u1E6F]|[\\u1E71-\\u1E71]|[\\u1E73-\\u1E73]|[\\u1E75-\\u1E75]|[\\u1E77-\\u1E77]|[\\u1E79-\\u1E79]|[\\u1E7B-\\u1E7B]|[\\u1E7D-\\u1E7D]|[\\u1E7F-\\u1E7F]|[\\u1E81-\\u1E81]|[\\u1E83-\\u1E83]|[\\u1E85-\\u1E85]|[\\u1E87-\\u1E87]|[\\u1E89-\\u1E89]|[\\u1E8B-\\u1E8B]|[\\u1E8D-\\u1E8D]|[\\u1E8F-\\u1E8F]|[\\u1E91-\\u1E91]|[\\u1E93-\\u1E93]|[\\u1E95-\\u1E9B]|[\\u1EA1-\\u1EA1]|[\\u1EA3-\\u1EA3]|[\\u1EA5-\\u1EA5]|[\\u1EA7-\\u1EA7]|[\\u1EA9-\\u1EA9]|[\\u1EAB-\\u1EAB]|[\\u1EAD-\\u1EAD]|[\\u1EAF-\\u1EAF]|[\\u1EB1-\\u1EB1]|[\\u1EB3-\\u1EB3]|[\\u1EB5-\\u1EB5]|[\\u1EB7-\\u1EB7]|[\\u1EB9-\\u1EB9]|[\\u1EBB-\\u1EBB]|[\\u1EBD-\\u1EBD]|[\\u1EBF-\\u1EBF]|[\\u1EC1-\\u1EC1]|[\\u1EC3-\\u1EC3]|[\\u1EC5-\\u1EC5]|[\\u1EC7-\\u1EC7]|[\\u1EC9-\\u1EC9]|[\\u1ECB-\\u1ECB]|[\\u1ECD-\\u1ECD]|[\\u1ECF-\\u1ECF]|[\\u1ED1-\\u1ED1]|[\\u1ED3-\\u1ED3]|[\\u1ED5-\\u1ED5]|[\\u1ED7-\\u1ED7]|[\\u1ED9-\\u1ED9]|[\\u1EDB-\\u1EDB]|[\\u1EDD-\\u1EDD]|[\\u1EDF-\\u1EDF]|[\\u1EE1-\\u1EE1]|[\\u1EE3-\\u1EE3]|[\\u1EE5-\\u1EE5]|[\\u1EE7-\\u1EE7]|[\\u1EE9-\\u1EE9]|[\\u1EEB-\\u1EEB]|[\\u1EED-\\u1EED]|[\\u1EEF-\\u1EEF]|[\\u1EF1-\\u1EF1]|[\\u1EF3-\\u1EF3]|[\\u1EF5-\\u1EF5]|[\\u1EF7-\\u1EF7]|[\\u1EF9-\\u1EF9]|[\\u1F00-\\u1F07]|[\\u1F10-\\u1F15]|[\\u1F20-\\u1F27]|[\\u1F30-\\u1F37]|[\\u1F40-\\u1F45]|[\\u1F50-\\u1F57]|[\\u1F60-\\u1F67]|[\\u1F70-\\u1F7D]|[\\u1F80-\\u1F87]|[\\u1F90-\\u1F97]|[\\u1FA0-\\u1FA7]|[\\u1FB0-\\u1FB4]|[\\u1FB6-\\u1FB7]|[\\u1FBE-\\u1FBE]|[\\u1FC2-\\u1FC4]|[\\u1FC6-\\u1FC7]|[\\u1FD0-\\u1FD3]|[\\u1FD6-\\u1FD7]|[\\u1FE0-\\u1FE7]|[\\u1FF2-\\u1FF4]|[\\u1FF6-\\u1FF7]|[\\u207F-\\u207F]|[\\u210A-\\u210A]|[\\u210E-\\u210F]|[\\u2113-\\u2113]|[\\u2118-\\u2118]|[\\u212E-\\u212F]|[\\u2134-\\u2134]|[\\uFB00-\\uFB06]|[\\uFB13-\\uFB17]|[\\uFF41-\\uFF5A]/,\n  Lt: /[\\u01C5-\\u01C5]|[\\u01C8-\\u01C8]|[\\u01CB-\\u01CB]|[\\u01F2-\\u01F2]/,\n  Lm: /[\\u02B0-\\u02B8]|[\\u02BB-\\u02C1]|[\\u02D0-\\u02D1]|[\\u02E0-\\u02E4]|[\\u037A-\\u037A]|[\\u0559-\\u0559]|[\\u0640-\\u0640]|[\\u06E5-\\u06E6]|[\\u0E46-\\u0E46]|[\\u0EC6-\\u0EC6]|[\\u3005-\\u3005]|[\\u3031-\\u3035]|[\\u309D-\\u309E]|[\\u30FC-\\u30FE]|[\\uFF70-\\uFF70]|[\\uFF9E-\\uFF9F]/,\n  Lo: /[\\u01AA-\\u01AA]|[\\u01BB-\\u01BB]|[\\u01BE-\\u01C3]|[\\u03F3-\\u03F3]|[\\u04C0-\\u04C0]|[\\u05D0-\\u05EA]|[\\u05F0-\\u05F2]|[\\u0621-\\u063A]|[\\u0641-\\u064A]|[\\u0671-\\u06B7]|[\\u06BA-\\u06BE]|[\\u06C0-\\u06CE]|[\\u06D0-\\u06D3]|[\\u06D5-\\u06D5]|[\\u0905-\\u0939]|[\\u093D-\\u093D]|[\\u0950-\\u0950]|[\\u0958-\\u0961]|[\\u0985-\\u098C]|[\\u098F-\\u0990]|[\\u0993-\\u09A8]|[\\u09AA-\\u09B0]|[\\u09B2-\\u09B2]|[\\u09B6-\\u09B9]|[\\u09DC-\\u09DD]|[\\u09DF-\\u09E1]|[\\u09F0-\\u09F1]|[\\u0A05-\\u0A0A]|[\\u0A0F-\\u0A10]|[\\u0A13-\\u0A28]|[\\u0A2A-\\u0A30]|[\\u0A32-\\u0A33]|[\\u0A35-\\u0A36]|[\\u0A38-\\u0A39]|[\\u0A59-\\u0A5C]|[\\u0A5E-\\u0A5E]|[\\u0A72-\\u0A74]|[\\u0A85-\\u0A8B]|[\\u0A8D-\\u0A8D]|[\\u0A8F-\\u0A91]|[\\u0A93-\\u0AA8]|[\\u0AAA-\\u0AB0]|[\\u0AB2-\\u0AB3]|[\\u0AB5-\\u0AB9]|[\\u0ABD-\\u0ABD]|[\\u0AD0-\\u0AD0]|[\\u0AE0-\\u0AE0]|[\\u0B05-\\u0B0C]|[\\u0B0F-\\u0B10]|[\\u0B13-\\u0B28]|[\\u0B2A-\\u0B30]|[\\u0B32-\\u0B33]|[\\u0B36-\\u0B39]|[\\u0B3D-\\u0B3D]|[\\u0B5C-\\u0B5D]|[\\u0B5F-\\u0B61]|[\\u0B85-\\u0B8A]|[\\u0B8E-\\u0B90]|[\\u0B92-\\u0B95]|[\\u0B99-\\u0B9A]|[\\u0B9C-\\u0B9C]|[\\u0B9E-\\u0B9F]|[\\u0BA3-\\u0BA4]|[\\u0BA8-\\u0BAA]|[\\u0BAE-\\u0BB5]|[\\u0BB7-\\u0BB9]|[\\u0C05-\\u0C0C]|[\\u0C0E-\\u0C10]|[\\u0C12-\\u0C28]|[\\u0C2A-\\u0C33]|[\\u0C35-\\u0C39]|[\\u0C60-\\u0C61]|[\\u0C85-\\u0C8C]|[\\u0C8E-\\u0C90]|[\\u0C92-\\u0CA8]|[\\u0CAA-\\u0CB3]|[\\u0CB5-\\u0CB9]|[\\u0CDE-\\u0CDE]|[\\u0CE0-\\u0CE1]|[\\u0D05-\\u0D0C]|[\\u0D0E-\\u0D10]|[\\u0D12-\\u0D28]|[\\u0D2A-\\u0D39]|[\\u0D60-\\u0D61]|[\\u0E01-\\u0E30]|[\\u0E32-\\u0E33]|[\\u0E40-\\u0E45]|[\\u0E81-\\u0E82]|[\\u0E84-\\u0E84]|[\\u0E87-\\u0E88]|[\\u0E8A-\\u0E8A]|[\\u0E8D-\\u0E8D]|[\\u0E94-\\u0E97]|[\\u0E99-\\u0E9F]|[\\u0EA1-\\u0EA3]|[\\u0EA5-\\u0EA5]|[\\u0EA7-\\u0EA7]|[\\u0EAA-\\u0EAB]|[\\u0EAD-\\u0EB0]|[\\u0EB2-\\u0EB3]|[\\u0EBD-\\u0EBD]|[\\u0EC0-\\u0EC4]|[\\u0EDC-\\u0EDD]|[\\u0F00-\\u0F00]|[\\u0F40-\\u0F47]|[\\u0F49-\\u0F69]|[\\u0F88-\\u0F8B]|[\\u1100-\\u1159]|[\\u115F-\\u11A2]|[\\u11A8-\\u11F9]|[\\u2135-\\u2138]|[\\u3006-\\u3006]|[\\u3041-\\u3094]|[\\u30A1-\\u30FA]|[\\u3105-\\u312C]|[\\u3131-\\u318E]|[\\u4E00-\\u9FA5]|[\\uAC00-\\uD7A3]|[\\uF900-\\uFA2D]|[\\uFB1F-\\uFB28]|[\\uFB2A-\\uFB36]|[\\uFB38-\\uFB3C]|[\\uFB3E-\\uFB3E]|[\\uFB40-\\uFB41]|[\\uFB43-\\uFB44]|[\\uFB46-\\uFBB1]|[\\uFBD3-\\uFD3D]|[\\uFD50-\\uFD8F]|[\\uFD92-\\uFDC7]|[\\uFDF0-\\uFDFB]|[\\uFE70-\\uFE72]|[\\uFE74-\\uFE74]|[\\uFE76-\\uFEFC]|[\\uFF66-\\uFF6F]|[\\uFF71-\\uFF9D]|[\\uFFA0-\\uFFBE]|[\\uFFC2-\\uFFC7]|[\\uFFCA-\\uFFCF]|[\\uFFD2-\\uFFD7]|[\\uFFDA-\\uFFDC]/,\n\n  // Numbers\n  Nl: /[\\u2160-\\u2182]|[\\u3007-\\u3007]|[\\u3021-\\u3029]/,\n  Nd: /[\\u0030-\\u0039]|[\\u0660-\\u0669]|[\\u06F0-\\u06F9]|[\\u0966-\\u096F]|[\\u09E6-\\u09EF]|[\\u0A66-\\u0A6F]|[\\u0AE6-\\u0AEF]|[\\u0B66-\\u0B6F]|[\\u0BE7-\\u0BEF]|[\\u0C66-\\u0C6F]|[\\u0CE6-\\u0CEF]|[\\u0D66-\\u0D6F]|[\\u0E50-\\u0E59]|[\\u0ED0-\\u0ED9]|[\\u0F20-\\u0F29]|[\\uFF10-\\uFF19]/,\n\n  // Marks\n  Mn: /[\\u0300-\\u0345]|[\\u0360-\\u0361]|[\\u0483-\\u0486]|[\\u0591-\\u05A1]|[\\u05A3-\\u05B9]|[\\u05BB-\\u05BD]|[\\u05BF-\\u05BF]|[\\u05C1-\\u05C2]|[\\u05C4-\\u05C4]|[\\u064B-\\u0652]|[\\u0670-\\u0670]|[\\u06D6-\\u06DC]|[\\u06DF-\\u06E4]|[\\u06E7-\\u06E8]|[\\u06EA-\\u06ED]|[\\u0901-\\u0902]|[\\u093C-\\u093C]|[\\u0941-\\u0948]|[\\u094D-\\u094D]|[\\u0951-\\u0954]|[\\u0962-\\u0963]|[\\u0981-\\u0981]|[\\u09BC-\\u09BC]|[\\u09C1-\\u09C4]|[\\u09CD-\\u09CD]|[\\u09E2-\\u09E3]|[\\u0A02-\\u0A02]|[\\u0A3C-\\u0A3C]|[\\u0A41-\\u0A42]|[\\u0A47-\\u0A48]|[\\u0A4B-\\u0A4D]|[\\u0A70-\\u0A71]|[\\u0A81-\\u0A82]|[\\u0ABC-\\u0ABC]|[\\u0AC1-\\u0AC5]|[\\u0AC7-\\u0AC8]|[\\u0ACD-\\u0ACD]|[\\u0B01-\\u0B01]|[\\u0B3C-\\u0B3C]|[\\u0B3F-\\u0B3F]|[\\u0B41-\\u0B43]|[\\u0B4D-\\u0B4D]|[\\u0B56-\\u0B56]|[\\u0B82-\\u0B82]|[\\u0BC0-\\u0BC0]|[\\u0BCD-\\u0BCD]|[\\u0C3E-\\u0C40]|[\\u0C46-\\u0C48]|[\\u0C4A-\\u0C4D]|[\\u0C55-\\u0C56]|[\\u0CBF-\\u0CBF]|[\\u0CC6-\\u0CC6]|[\\u0CCC-\\u0CCD]|[\\u0D41-\\u0D43]|[\\u0D4D-\\u0D4D]|[\\u0E31-\\u0E31]|[\\u0E34-\\u0E3A]|[\\u0E47-\\u0E4E]|[\\u0EB1-\\u0EB1]|[\\u0EB4-\\u0EB9]|[\\u0EBB-\\u0EBC]|[\\u0EC8-\\u0ECD]|[\\u0F18-\\u0F19]|[\\u0F35-\\u0F35]|[\\u0F37-\\u0F37]|[\\u0F39-\\u0F39]|[\\u0F71-\\u0F7E]|[\\u0F80-\\u0F84]|[\\u0F86-\\u0F87]|[\\u0F90-\\u0F95]|[\\u0F97-\\u0F97]|[\\u0F99-\\u0FAD]|[\\u0FB1-\\u0FB7]|[\\u0FB9-\\u0FB9]|[\\u20D0-\\u20DC]|[\\u20E1-\\u20E1]|[\\u302A-\\u302F]|[\\u3099-\\u309A]|[\\uFB1E-\\uFB1E]|[\\uFE20-\\uFE23]/,\n  Mc: /[\\u0903-\\u0903]|[\\u093E-\\u0940]|[\\u0949-\\u094C]|[\\u0982-\\u0983]|[\\u09BE-\\u09C0]|[\\u09C7-\\u09C8]|[\\u09CB-\\u09CC]|[\\u09D7-\\u09D7]|[\\u0A3E-\\u0A40]|[\\u0A83-\\u0A83]|[\\u0ABE-\\u0AC0]|[\\u0AC9-\\u0AC9]|[\\u0ACB-\\u0ACC]|[\\u0B02-\\u0B03]|[\\u0B3E-\\u0B3E]|[\\u0B40-\\u0B40]|[\\u0B47-\\u0B48]|[\\u0B4B-\\u0B4C]|[\\u0B57-\\u0B57]|[\\u0B83-\\u0B83]|[\\u0BBE-\\u0BBF]|[\\u0BC1-\\u0BC2]|[\\u0BC6-\\u0BC8]|[\\u0BCA-\\u0BCC]|[\\u0BD7-\\u0BD7]|[\\u0C01-\\u0C03]|[\\u0C41-\\u0C44]|[\\u0C82-\\u0C83]|[\\u0CBE-\\u0CBE]|[\\u0CC0-\\u0CC4]|[\\u0CC7-\\u0CC8]|[\\u0CCA-\\u0CCB]|[\\u0CD5-\\u0CD6]|[\\u0D02-\\u0D03]|[\\u0D3E-\\u0D40]|[\\u0D46-\\u0D48]|[\\u0D4A-\\u0D4C]|[\\u0D57-\\u0D57]|[\\u0F3E-\\u0F3F]|[\\u0F7F-\\u0F7F]/,\n\n  // Punctuation, Connector\n  Pc: /[\\u005F-\\u005F]|[\\u203F-\\u2040]|[\\u30FB-\\u30FB]|[\\uFE33-\\uFE34]|[\\uFE4D-\\uFE4F]|[\\uFF3F-\\uFF3F]|[\\uFF65-\\uFF65]/,\n\n  // Separator, Space\n  Zs: /[\\u2000-\\u200B]|[\\u3000-\\u3000]/,\n\n  // These two are not real Unicode categories, but our useful for Ohm.\n  // L is a combination of all the letter categories.\n  // Ltmo is a combination of Lt, Lm, and Lo.\n  L: /[\\u0041-\\u005A]|[\\u00C0-\\u00D6]|[\\u00D8-\\u00DE]|[\\u0100-\\u0100]|[\\u0102-\\u0102]|[\\u0104-\\u0104]|[\\u0106-\\u0106]|[\\u0108-\\u0108]|[\\u010A-\\u010A]|[\\u010C-\\u010C]|[\\u010E-\\u010E]|[\\u0110-\\u0110]|[\\u0112-\\u0112]|[\\u0114-\\u0114]|[\\u0116-\\u0116]|[\\u0118-\\u0118]|[\\u011A-\\u011A]|[\\u011C-\\u011C]|[\\u011E-\\u011E]|[\\u0120-\\u0120]|[\\u0122-\\u0122]|[\\u0124-\\u0124]|[\\u0126-\\u0126]|[\\u0128-\\u0128]|[\\u012A-\\u012A]|[\\u012C-\\u012C]|[\\u012E-\\u012E]|[\\u0130-\\u0130]|[\\u0132-\\u0132]|[\\u0134-\\u0134]|[\\u0136-\\u0136]|[\\u0139-\\u0139]|[\\u013B-\\u013B]|[\\u013D-\\u013D]|[\\u013F-\\u013F]|[\\u0141-\\u0141]|[\\u0143-\\u0143]|[\\u0145-\\u0145]|[\\u0147-\\u0147]|[\\u014A-\\u014A]|[\\u014C-\\u014C]|[\\u014E-\\u014E]|[\\u0150-\\u0150]|[\\u0152-\\u0152]|[\\u0154-\\u0154]|[\\u0156-\\u0156]|[\\u0158-\\u0158]|[\\u015A-\\u015A]|[\\u015C-\\u015C]|[\\u015E-\\u015E]|[\\u0160-\\u0160]|[\\u0162-\\u0162]|[\\u0164-\\u0164]|[\\u0166-\\u0166]|[\\u0168-\\u0168]|[\\u016A-\\u016A]|[\\u016C-\\u016C]|[\\u016E-\\u016E]|[\\u0170-\\u0170]|[\\u0172-\\u0172]|[\\u0174-\\u0174]|[\\u0176-\\u0176]|[\\u0178-\\u0179]|[\\u017B-\\u017B]|[\\u017D-\\u017D]|[\\u0181-\\u0182]|[\\u0184-\\u0184]|[\\u0186-\\u0187]|[\\u0189-\\u018B]|[\\u018E-\\u0191]|[\\u0193-\\u0194]|[\\u0196-\\u0198]|[\\u019C-\\u019D]|[\\u019F-\\u01A0]|[\\u01A2-\\u01A2]|[\\u01A4-\\u01A4]|[\\u01A6-\\u01A7]|[\\u01A9-\\u01A9]|[\\u01AC-\\u01AC]|[\\u01AE-\\u01AF]|[\\u01B1-\\u01B3]|[\\u01B5-\\u01B5]|[\\u01B7-\\u01B8]|[\\u01BC-\\u01BC]|[\\u01C4-\\u01C4]|[\\u01C7-\\u01C7]|[\\u01CA-\\u01CA]|[\\u01CD-\\u01CD]|[\\u01CF-\\u01CF]|[\\u01D1-\\u01D1]|[\\u01D3-\\u01D3]|[\\u01D5-\\u01D5]|[\\u01D7-\\u01D7]|[\\u01D9-\\u01D9]|[\\u01DB-\\u01DB]|[\\u01DE-\\u01DE]|[\\u01E0-\\u01E0]|[\\u01E2-\\u01E2]|[\\u01E4-\\u01E4]|[\\u01E6-\\u01E6]|[\\u01E8-\\u01E8]|[\\u01EA-\\u01EA]|[\\u01EC-\\u01EC]|[\\u01EE-\\u01EE]|[\\u01F1-\\u01F1]|[\\u01F4-\\u01F4]|[\\u01FA-\\u01FA]|[\\u01FC-\\u01FC]|[\\u01FE-\\u01FE]|[\\u0200-\\u0200]|[\\u0202-\\u0202]|[\\u0204-\\u0204]|[\\u0206-\\u0206]|[\\u0208-\\u0208]|[\\u020A-\\u020A]|[\\u020C-\\u020C]|[\\u020E-\\u020E]|[\\u0210-\\u0210]|[\\u0212-\\u0212]|[\\u0214-\\u0214]|[\\u0216-\\u0216]|[\\u0386-\\u0386]|[\\u0388-\\u038A]|[\\u038C-\\u038C]|[\\u038E-\\u038F]|[\\u0391-\\u03A1]|[\\u03A3-\\u03AB]|[\\u03D2-\\u03D4]|[\\u03DA-\\u03DA]|[\\u03DC-\\u03DC]|[\\u03DE-\\u03DE]|[\\u03E0-\\u03E0]|[\\u03E2-\\u03E2]|[\\u03E4-\\u03E4]|[\\u03E6-\\u03E6]|[\\u03E8-\\u03E8]|[\\u03EA-\\u03EA]|[\\u03EC-\\u03EC]|[\\u03EE-\\u03EE]|[\\u0401-\\u040C]|[\\u040E-\\u042F]|[\\u0460-\\u0460]|[\\u0462-\\u0462]|[\\u0464-\\u0464]|[\\u0466-\\u0466]|[\\u0468-\\u0468]|[\\u046A-\\u046A]|[\\u046C-\\u046C]|[\\u046E-\\u046E]|[\\u0470-\\u0470]|[\\u0472-\\u0472]|[\\u0474-\\u0474]|[\\u0476-\\u0476]|[\\u0478-\\u0478]|[\\u047A-\\u047A]|[\\u047C-\\u047C]|[\\u047E-\\u047E]|[\\u0480-\\u0480]|[\\u0490-\\u0490]|[\\u0492-\\u0492]|[\\u0494-\\u0494]|[\\u0496-\\u0496]|[\\u0498-\\u0498]|[\\u049A-\\u049A]|[\\u049C-\\u049C]|[\\u049E-\\u049E]|[\\u04A0-\\u04A0]|[\\u04A2-\\u04A2]|[\\u04A4-\\u04A4]|[\\u04A6-\\u04A6]|[\\u04A8-\\u04A8]|[\\u04AA-\\u04AA]|[\\u04AC-\\u04AC]|[\\u04AE-\\u04AE]|[\\u04B0-\\u04B0]|[\\u04B2-\\u04B2]|[\\u04B4-\\u04B4]|[\\u04B6-\\u04B6]|[\\u04B8-\\u04B8]|[\\u04BA-\\u04BA]|[\\u04BC-\\u04BC]|[\\u04BE-\\u04BE]|[\\u04C1-\\u04C1]|[\\u04C3-\\u04C3]|[\\u04C7-\\u04C7]|[\\u04CB-\\u04CB]|[\\u04D0-\\u04D0]|[\\u04D2-\\u04D2]|[\\u04D4-\\u04D4]|[\\u04D6-\\u04D6]|[\\u04D8-\\u04D8]|[\\u04DA-\\u04DA]|[\\u04DC-\\u04DC]|[\\u04DE-\\u04DE]|[\\u04E0-\\u04E0]|[\\u04E2-\\u04E2]|[\\u04E4-\\u04E4]|[\\u04E6-\\u04E6]|[\\u04E8-\\u04E8]|[\\u04EA-\\u04EA]|[\\u04EE-\\u04EE]|[\\u04F0-\\u04F0]|[\\u04F2-\\u04F2]|[\\u04F4-\\u04F4]|[\\u04F8-\\u04F8]|[\\u0531-\\u0556]|[\\u10A0-\\u10C5]|[\\u1E00-\\u1E00]|[\\u1E02-\\u1E02]|[\\u1E04-\\u1E04]|[\\u1E06-\\u1E06]|[\\u1E08-\\u1E08]|[\\u1E0A-\\u1E0A]|[\\u1E0C-\\u1E0C]|[\\u1E0E-\\u1E0E]|[\\u1E10-\\u1E10]|[\\u1E12-\\u1E12]|[\\u1E14-\\u1E14]|[\\u1E16-\\u1E16]|[\\u1E18-\\u1E18]|[\\u1E1A-\\u1E1A]|[\\u1E1C-\\u1E1C]|[\\u1E1E-\\u1E1E]|[\\u1E20-\\u1E20]|[\\u1E22-\\u1E22]|[\\u1E24-\\u1E24]|[\\u1E26-\\u1E26]|[\\u1E28-\\u1E28]|[\\u1E2A-\\u1E2A]|[\\u1E2C-\\u1E2C]|[\\u1E2E-\\u1E2E]|[\\u1E30-\\u1E30]|[\\u1E32-\\u1E32]|[\\u1E34-\\u1E34]|[\\u1E36-\\u1E36]|[\\u1E38-\\u1E38]|[\\u1E3A-\\u1E3A]|[\\u1E3C-\\u1E3C]|[\\u1E3E-\\u1E3E]|[\\u1E40-\\u1E40]|[\\u1E42-\\u1E42]|[\\u1E44-\\u1E44]|[\\u1E46-\\u1E46]|[\\u1E48-\\u1E48]|[\\u1E4A-\\u1E4A]|[\\u1E4C-\\u1E4C]|[\\u1E4E-\\u1E4E]|[\\u1E50-\\u1E50]|[\\u1E52-\\u1E52]|[\\u1E54-\\u1E54]|[\\u1E56-\\u1E56]|[\\u1E58-\\u1E58]|[\\u1E5A-\\u1E5A]|[\\u1E5C-\\u1E5C]|[\\u1E5E-\\u1E5E]|[\\u1E60-\\u1E60]|[\\u1E62-\\u1E62]|[\\u1E64-\\u1E64]|[\\u1E66-\\u1E66]|[\\u1E68-\\u1E68]|[\\u1E6A-\\u1E6A]|[\\u1E6C-\\u1E6C]|[\\u1E6E-\\u1E6E]|[\\u1E70-\\u1E70]|[\\u1E72-\\u1E72]|[\\u1E74-\\u1E74]|[\\u1E76-\\u1E76]|[\\u1E78-\\u1E78]|[\\u1E7A-\\u1E7A]|[\\u1E7C-\\u1E7C]|[\\u1E7E-\\u1E7E]|[\\u1E80-\\u1E80]|[\\u1E82-\\u1E82]|[\\u1E84-\\u1E84]|[\\u1E86-\\u1E86]|[\\u1E88-\\u1E88]|[\\u1E8A-\\u1E8A]|[\\u1E8C-\\u1E8C]|[\\u1E8E-\\u1E8E]|[\\u1E90-\\u1E90]|[\\u1E92-\\u1E92]|[\\u1E94-\\u1E94]|[\\u1EA0-\\u1EA0]|[\\u1EA2-\\u1EA2]|[\\u1EA4-\\u1EA4]|[\\u1EA6-\\u1EA6]|[\\u1EA8-\\u1EA8]|[\\u1EAA-\\u1EAA]|[\\u1EAC-\\u1EAC]|[\\u1EAE-\\u1EAE]|[\\u1EB0-\\u1EB0]|[\\u1EB2-\\u1EB2]|[\\u1EB4-\\u1EB4]|[\\u1EB6-\\u1EB6]|[\\u1EB8-\\u1EB8]|[\\u1EBA-\\u1EBA]|[\\u1EBC-\\u1EBC]|[\\u1EBE-\\u1EBE]|[\\u1EC0-\\u1EC0]|[\\u1EC2-\\u1EC2]|[\\u1EC4-\\u1EC4]|[\\u1EC6-\\u1EC6]|[\\u1EC8-\\u1EC8]|[\\u1ECA-\\u1ECA]|[\\u1ECC-\\u1ECC]|[\\u1ECE-\\u1ECE]|[\\u1ED0-\\u1ED0]|[\\u1ED2-\\u1ED2]|[\\u1ED4-\\u1ED4]|[\\u1ED6-\\u1ED6]|[\\u1ED8-\\u1ED8]|[\\u1EDA-\\u1EDA]|[\\u1EDC-\\u1EDC]|[\\u1EDE-\\u1EDE]|[\\u1EE0-\\u1EE0]|[\\u1EE2-\\u1EE2]|[\\u1EE4-\\u1EE4]|[\\u1EE6-\\u1EE6]|[\\u1EE8-\\u1EE8]|[\\u1EEA-\\u1EEA]|[\\u1EEC-\\u1EEC]|[\\u1EEE-\\u1EEE]|[\\u1EF0-\\u1EF0]|[\\u1EF2-\\u1EF2]|[\\u1EF4-\\u1EF4]|[\\u1EF6-\\u1EF6]|[\\u1EF8-\\u1EF8]|[\\u1F08-\\u1F0F]|[\\u1F18-\\u1F1D]|[\\u1F28-\\u1F2F]|[\\u1F38-\\u1F3F]|[\\u1F48-\\u1F4D]|[\\u1F59-\\u1F59]|[\\u1F5B-\\u1F5B]|[\\u1F5D-\\u1F5D]|[\\u1F5F-\\u1F5F]|[\\u1F68-\\u1F6F]|[\\u1F88-\\u1F8F]|[\\u1F98-\\u1F9F]|[\\u1FA8-\\u1FAF]|[\\u1FB8-\\u1FBC]|[\\u1FC8-\\u1FCC]|[\\u1FD8-\\u1FDB]|[\\u1FE8-\\u1FEC]|[\\u1FF8-\\u1FFC]|[\\u2102-\\u2102]|[\\u2107-\\u2107]|[\\u210B-\\u210D]|[\\u2110-\\u2112]|[\\u2115-\\u2115]|[\\u2119-\\u211D]|[\\u2124-\\u2124]|[\\u2126-\\u2126]|[\\u2128-\\u2128]|[\\u212A-\\u212D]|[\\u2130-\\u2131]|[\\u2133-\\u2133]|[\\uFF21-\\uFF3A]|[\\u0061-\\u007A]|[\\u00AA-\\u00AA]|[\\u00B5-\\u00B5]|[\\u00BA-\\u00BA]|[\\u00DF-\\u00F6]|[\\u00F8-\\u00FF]|[\\u0101-\\u0101]|[\\u0103-\\u0103]|[\\u0105-\\u0105]|[\\u0107-\\u0107]|[\\u0109-\\u0109]|[\\u010B-\\u010B]|[\\u010D-\\u010D]|[\\u010F-\\u010F]|[\\u0111-\\u0111]|[\\u0113-\\u0113]|[\\u0115-\\u0115]|[\\u0117-\\u0117]|[\\u0119-\\u0119]|[\\u011B-\\u011B]|[\\u011D-\\u011D]|[\\u011F-\\u011F]|[\\u0121-\\u0121]|[\\u0123-\\u0123]|[\\u0125-\\u0125]|[\\u0127-\\u0127]|[\\u0129-\\u0129]|[\\u012B-\\u012B]|[\\u012D-\\u012D]|[\\u012F-\\u012F]|[\\u0131-\\u0131]|[\\u0133-\\u0133]|[\\u0135-\\u0135]|[\\u0137-\\u0138]|[\\u013A-\\u013A]|[\\u013C-\\u013C]|[\\u013E-\\u013E]|[\\u0140-\\u0140]|[\\u0142-\\u0142]|[\\u0144-\\u0144]|[\\u0146-\\u0146]|[\\u0148-\\u0149]|[\\u014B-\\u014B]|[\\u014D-\\u014D]|[\\u014F-\\u014F]|[\\u0151-\\u0151]|[\\u0153-\\u0153]|[\\u0155-\\u0155]|[\\u0157-\\u0157]|[\\u0159-\\u0159]|[\\u015B-\\u015B]|[\\u015D-\\u015D]|[\\u015F-\\u015F]|[\\u0161-\\u0161]|[\\u0163-\\u0163]|[\\u0165-\\u0165]|[\\u0167-\\u0167]|[\\u0169-\\u0169]|[\\u016B-\\u016B]|[\\u016D-\\u016D]|[\\u016F-\\u016F]|[\\u0171-\\u0171]|[\\u0173-\\u0173]|[\\u0175-\\u0175]|[\\u0177-\\u0177]|[\\u017A-\\u017A]|[\\u017C-\\u017C]|[\\u017E-\\u0180]|[\\u0183-\\u0183]|[\\u0185-\\u0185]|[\\u0188-\\u0188]|[\\u018C-\\u018D]|[\\u0192-\\u0192]|[\\u0195-\\u0195]|[\\u0199-\\u019B]|[\\u019E-\\u019E]|[\\u01A1-\\u01A1]|[\\u01A3-\\u01A3]|[\\u01A5-\\u01A5]|[\\u01A8-\\u01A8]|[\\u01AB-\\u01AB]|[\\u01AD-\\u01AD]|[\\u01B0-\\u01B0]|[\\u01B4-\\u01B4]|[\\u01B6-\\u01B6]|[\\u01B9-\\u01BA]|[\\u01BD-\\u01BD]|[\\u01C6-\\u01C6]|[\\u01C9-\\u01C9]|[\\u01CC-\\u01CC]|[\\u01CE-\\u01CE]|[\\u01D0-\\u01D0]|[\\u01D2-\\u01D2]|[\\u01D4-\\u01D4]|[\\u01D6-\\u01D6]|[\\u01D8-\\u01D8]|[\\u01DA-\\u01DA]|[\\u01DC-\\u01DD]|[\\u01DF-\\u01DF]|[\\u01E1-\\u01E1]|[\\u01E3-\\u01E3]|[\\u01E5-\\u01E5]|[\\u01E7-\\u01E7]|[\\u01E9-\\u01E9]|[\\u01EB-\\u01EB]|[\\u01ED-\\u01ED]|[\\u01EF-\\u01F0]|[\\u01F3-\\u01F3]|[\\u01F5-\\u01F5]|[\\u01FB-\\u01FB]|[\\u01FD-\\u01FD]|[\\u01FF-\\u01FF]|[\\u0201-\\u0201]|[\\u0203-\\u0203]|[\\u0205-\\u0205]|[\\u0207-\\u0207]|[\\u0209-\\u0209]|[\\u020B-\\u020B]|[\\u020D-\\u020D]|[\\u020F-\\u020F]|[\\u0211-\\u0211]|[\\u0213-\\u0213]|[\\u0215-\\u0215]|[\\u0217-\\u0217]|[\\u0250-\\u02A8]|[\\u0390-\\u0390]|[\\u03AC-\\u03CE]|[\\u03D0-\\u03D1]|[\\u03D5-\\u03D6]|[\\u03E3-\\u03E3]|[\\u03E5-\\u03E5]|[\\u03E7-\\u03E7]|[\\u03E9-\\u03E9]|[\\u03EB-\\u03EB]|[\\u03ED-\\u03ED]|[\\u03EF-\\u03F2]|[\\u0430-\\u044F]|[\\u0451-\\u045C]|[\\u045E-\\u045F]|[\\u0461-\\u0461]|[\\u0463-\\u0463]|[\\u0465-\\u0465]|[\\u0467-\\u0467]|[\\u0469-\\u0469]|[\\u046B-\\u046B]|[\\u046D-\\u046D]|[\\u046F-\\u046F]|[\\u0471-\\u0471]|[\\u0473-\\u0473]|[\\u0475-\\u0475]|[\\u0477-\\u0477]|[\\u0479-\\u0479]|[\\u047B-\\u047B]|[\\u047D-\\u047D]|[\\u047F-\\u047F]|[\\u0481-\\u0481]|[\\u0491-\\u0491]|[\\u0493-\\u0493]|[\\u0495-\\u0495]|[\\u0497-\\u0497]|[\\u0499-\\u0499]|[\\u049B-\\u049B]|[\\u049D-\\u049D]|[\\u049F-\\u049F]|[\\u04A1-\\u04A1]|[\\u04A3-\\u04A3]|[\\u04A5-\\u04A5]|[\\u04A7-\\u04A7]|[\\u04A9-\\u04A9]|[\\u04AB-\\u04AB]|[\\u04AD-\\u04AD]|[\\u04AF-\\u04AF]|[\\u04B1-\\u04B1]|[\\u04B3-\\u04B3]|[\\u04B5-\\u04B5]|[\\u04B7-\\u04B7]|[\\u04B9-\\u04B9]|[\\u04BB-\\u04BB]|[\\u04BD-\\u04BD]|[\\u04BF-\\u04BF]|[\\u04C2-\\u04C2]|[\\u04C4-\\u04C4]|[\\u04C8-\\u04C8]|[\\u04CC-\\u04CC]|[\\u04D1-\\u04D1]|[\\u04D3-\\u04D3]|[\\u04D5-\\u04D5]|[\\u04D7-\\u04D7]|[\\u04D9-\\u04D9]|[\\u04DB-\\u04DB]|[\\u04DD-\\u04DD]|[\\u04DF-\\u04DF]|[\\u04E1-\\u04E1]|[\\u04E3-\\u04E3]|[\\u04E5-\\u04E5]|[\\u04E7-\\u04E7]|[\\u04E9-\\u04E9]|[\\u04EB-\\u04EB]|[\\u04EF-\\u04EF]|[\\u04F1-\\u04F1]|[\\u04F3-\\u04F3]|[\\u04F5-\\u04F5]|[\\u04F9-\\u04F9]|[\\u0561-\\u0587]|[\\u10D0-\\u10F6]|[\\u1E01-\\u1E01]|[\\u1E03-\\u1E03]|[\\u1E05-\\u1E05]|[\\u1E07-\\u1E07]|[\\u1E09-\\u1E09]|[\\u1E0B-\\u1E0B]|[\\u1E0D-\\u1E0D]|[\\u1E0F-\\u1E0F]|[\\u1E11-\\u1E11]|[\\u1E13-\\u1E13]|[\\u1E15-\\u1E15]|[\\u1E17-\\u1E17]|[\\u1E19-\\u1E19]|[\\u1E1B-\\u1E1B]|[\\u1E1D-\\u1E1D]|[\\u1E1F-\\u1E1F]|[\\u1E21-\\u1E21]|[\\u1E23-\\u1E23]|[\\u1E25-\\u1E25]|[\\u1E27-\\u1E27]|[\\u1E29-\\u1E29]|[\\u1E2B-\\u1E2B]|[\\u1E2D-\\u1E2D]|[\\u1E2F-\\u1E2F]|[\\u1E31-\\u1E31]|[\\u1E33-\\u1E33]|[\\u1E35-\\u1E35]|[\\u1E37-\\u1E37]|[\\u1E39-\\u1E39]|[\\u1E3B-\\u1E3B]|[\\u1E3D-\\u1E3D]|[\\u1E3F-\\u1E3F]|[\\u1E41-\\u1E41]|[\\u1E43-\\u1E43]|[\\u1E45-\\u1E45]|[\\u1E47-\\u1E47]|[\\u1E49-\\u1E49]|[\\u1E4B-\\u1E4B]|[\\u1E4D-\\u1E4D]|[\\u1E4F-\\u1E4F]|[\\u1E51-\\u1E51]|[\\u1E53-\\u1E53]|[\\u1E55-\\u1E55]|[\\u1E57-\\u1E57]|[\\u1E59-\\u1E59]|[\\u1E5B-\\u1E5B]|[\\u1E5D-\\u1E5D]|[\\u1E5F-\\u1E5F]|[\\u1E61-\\u1E61]|[\\u1E63-\\u1E63]|[\\u1E65-\\u1E65]|[\\u1E67-\\u1E67]|[\\u1E69-\\u1E69]|[\\u1E6B-\\u1E6B]|[\\u1E6D-\\u1E6D]|[\\u1E6F-\\u1E6F]|[\\u1E71-\\u1E71]|[\\u1E73-\\u1E73]|[\\u1E75-\\u1E75]|[\\u1E77-\\u1E77]|[\\u1E79-\\u1E79]|[\\u1E7B-\\u1E7B]|[\\u1E7D-\\u1E7D]|[\\u1E7F-\\u1E7F]|[\\u1E81-\\u1E81]|[\\u1E83-\\u1E83]|[\\u1E85-\\u1E85]|[\\u1E87-\\u1E87]|[\\u1E89-\\u1E89]|[\\u1E8B-\\u1E8B]|[\\u1E8D-\\u1E8D]|[\\u1E8F-\\u1E8F]|[\\u1E91-\\u1E91]|[\\u1E93-\\u1E93]|[\\u1E95-\\u1E9B]|[\\u1EA1-\\u1EA1]|[\\u1EA3-\\u1EA3]|[\\u1EA5-\\u1EA5]|[\\u1EA7-\\u1EA7]|[\\u1EA9-\\u1EA9]|[\\u1EAB-\\u1EAB]|[\\u1EAD-\\u1EAD]|[\\u1EAF-\\u1EAF]|[\\u1EB1-\\u1EB1]|[\\u1EB3-\\u1EB3]|[\\u1EB5-\\u1EB5]|[\\u1EB7-\\u1EB7]|[\\u1EB9-\\u1EB9]|[\\u1EBB-\\u1EBB]|[\\u1EBD-\\u1EBD]|[\\u1EBF-\\u1EBF]|[\\u1EC1-\\u1EC1]|[\\u1EC3-\\u1EC3]|[\\u1EC5-\\u1EC5]|[\\u1EC7-\\u1EC7]|[\\u1EC9-\\u1EC9]|[\\u1ECB-\\u1ECB]|[\\u1ECD-\\u1ECD]|[\\u1ECF-\\u1ECF]|[\\u1ED1-\\u1ED1]|[\\u1ED3-\\u1ED3]|[\\u1ED5-\\u1ED5]|[\\u1ED7-\\u1ED7]|[\\u1ED9-\\u1ED9]|[\\u1EDB-\\u1EDB]|[\\u1EDD-\\u1EDD]|[\\u1EDF-\\u1EDF]|[\\u1EE1-\\u1EE1]|[\\u1EE3-\\u1EE3]|[\\u1EE5-\\u1EE5]|[\\u1EE7-\\u1EE7]|[\\u1EE9-\\u1EE9]|[\\u1EEB-\\u1EEB]|[\\u1EED-\\u1EED]|[\\u1EEF-\\u1EEF]|[\\u1EF1-\\u1EF1]|[\\u1EF3-\\u1EF3]|[\\u1EF5-\\u1EF5]|[\\u1EF7-\\u1EF7]|[\\u1EF9-\\u1EF9]|[\\u1F00-\\u1F07]|[\\u1F10-\\u1F15]|[\\u1F20-\\u1F27]|[\\u1F30-\\u1F37]|[\\u1F40-\\u1F45]|[\\u1F50-\\u1F57]|[\\u1F60-\\u1F67]|[\\u1F70-\\u1F7D]|[\\u1F80-\\u1F87]|[\\u1F90-\\u1F97]|[\\u1FA0-\\u1FA7]|[\\u1FB0-\\u1FB4]|[\\u1FB6-\\u1FB7]|[\\u1FBE-\\u1FBE]|[\\u1FC2-\\u1FC4]|[\\u1FC6-\\u1FC7]|[\\u1FD0-\\u1FD3]|[\\u1FD6-\\u1FD7]|[\\u1FE0-\\u1FE7]|[\\u1FF2-\\u1FF4]|[\\u1FF6-\\u1FF7]|[\\u207F-\\u207F]|[\\u210A-\\u210A]|[\\u210E-\\u210F]|[\\u2113-\\u2113]|[\\u2118-\\u2118]|[\\u212E-\\u212F]|[\\u2134-\\u2134]|[\\uFB00-\\uFB06]|[\\uFB13-\\uFB17]|[\\uFF41-\\uFF5A]|[\\u01C5-\\u01C5]|[\\u01C8-\\u01C8]|[\\u01CB-\\u01CB]|[\\u01F2-\\u01F2]|[\\u02B0-\\u02B8]|[\\u02BB-\\u02C1]|[\\u02D0-\\u02D1]|[\\u02E0-\\u02E4]|[\\u037A-\\u037A]|[\\u0559-\\u0559]|[\\u0640-\\u0640]|[\\u06E5-\\u06E6]|[\\u0E46-\\u0E46]|[\\u0EC6-\\u0EC6]|[\\u3005-\\u3005]|[\\u3031-\\u3035]|[\\u309D-\\u309E]|[\\u30FC-\\u30FE]|[\\uFF70-\\uFF70]|[\\uFF9E-\\uFF9F]|[\\u01AA-\\u01AA]|[\\u01BB-\\u01BB]|[\\u01BE-\\u01C3]|[\\u03F3-\\u03F3]|[\\u04C0-\\u04C0]|[\\u05D0-\\u05EA]|[\\u05F0-\\u05F2]|[\\u0621-\\u063A]|[\\u0641-\\u064A]|[\\u0671-\\u06B7]|[\\u06BA-\\u06BE]|[\\u06C0-\\u06CE]|[\\u06D0-\\u06D3]|[\\u06D5-\\u06D5]|[\\u0905-\\u0939]|[\\u093D-\\u093D]|[\\u0950-\\u0950]|[\\u0958-\\u0961]|[\\u0985-\\u098C]|[\\u098F-\\u0990]|[\\u0993-\\u09A8]|[\\u09AA-\\u09B0]|[\\u09B2-\\u09B2]|[\\u09B6-\\u09B9]|[\\u09DC-\\u09DD]|[\\u09DF-\\u09E1]|[\\u09F0-\\u09F1]|[\\u0A05-\\u0A0A]|[\\u0A0F-\\u0A10]|[\\u0A13-\\u0A28]|[\\u0A2A-\\u0A30]|[\\u0A32-\\u0A33]|[\\u0A35-\\u0A36]|[\\u0A38-\\u0A39]|[\\u0A59-\\u0A5C]|[\\u0A5E-\\u0A5E]|[\\u0A72-\\u0A74]|[\\u0A85-\\u0A8B]|[\\u0A8D-\\u0A8D]|[\\u0A8F-\\u0A91]|[\\u0A93-\\u0AA8]|[\\u0AAA-\\u0AB0]|[\\u0AB2-\\u0AB3]|[\\u0AB5-\\u0AB9]|[\\u0ABD-\\u0ABD]|[\\u0AD0-\\u0AD0]|[\\u0AE0-\\u0AE0]|[\\u0B05-\\u0B0C]|[\\u0B0F-\\u0B10]|[\\u0B13-\\u0B28]|[\\u0B2A-\\u0B30]|[\\u0B32-\\u0B33]|[\\u0B36-\\u0B39]|[\\u0B3D-\\u0B3D]|[\\u0B5C-\\u0B5D]|[\\u0B5F-\\u0B61]|[\\u0B85-\\u0B8A]|[\\u0B8E-\\u0B90]|[\\u0B92-\\u0B95]|[\\u0B99-\\u0B9A]|[\\u0B9C-\\u0B9C]|[\\u0B9E-\\u0B9F]|[\\u0BA3-\\u0BA4]|[\\u0BA8-\\u0BAA]|[\\u0BAE-\\u0BB5]|[\\u0BB7-\\u0BB9]|[\\u0C05-\\u0C0C]|[\\u0C0E-\\u0C10]|[\\u0C12-\\u0C28]|[\\u0C2A-\\u0C33]|[\\u0C35-\\u0C39]|[\\u0C60-\\u0C61]|[\\u0C85-\\u0C8C]|[\\u0C8E-\\u0C90]|[\\u0C92-\\u0CA8]|[\\u0CAA-\\u0CB3]|[\\u0CB5-\\u0CB9]|[\\u0CDE-\\u0CDE]|[\\u0CE0-\\u0CE1]|[\\u0D05-\\u0D0C]|[\\u0D0E-\\u0D10]|[\\u0D12-\\u0D28]|[\\u0D2A-\\u0D39]|[\\u0D60-\\u0D61]|[\\u0E01-\\u0E30]|[\\u0E32-\\u0E33]|[\\u0E40-\\u0E45]|[\\u0E81-\\u0E82]|[\\u0E84-\\u0E84]|[\\u0E87-\\u0E88]|[\\u0E8A-\\u0E8A]|[\\u0E8D-\\u0E8D]|[\\u0E94-\\u0E97]|[\\u0E99-\\u0E9F]|[\\u0EA1-\\u0EA3]|[\\u0EA5-\\u0EA5]|[\\u0EA7-\\u0EA7]|[\\u0EAA-\\u0EAB]|[\\u0EAD-\\u0EB0]|[\\u0EB2-\\u0EB3]|[\\u0EBD-\\u0EBD]|[\\u0EC0-\\u0EC4]|[\\u0EDC-\\u0EDD]|[\\u0F00-\\u0F00]|[\\u0F40-\\u0F47]|[\\u0F49-\\u0F69]|[\\u0F88-\\u0F8B]|[\\u1100-\\u1159]|[\\u115F-\\u11A2]|[\\u11A8-\\u11F9]|[\\u2135-\\u2138]|[\\u3006-\\u3006]|[\\u3041-\\u3094]|[\\u30A1-\\u30FA]|[\\u3105-\\u312C]|[\\u3131-\\u318E]|[\\u4E00-\\u9FA5]|[\\uAC00-\\uD7A3]|[\\uF900-\\uFA2D]|[\\uFB1F-\\uFB28]|[\\uFB2A-\\uFB36]|[\\uFB38-\\uFB3C]|[\\uFB3E-\\uFB3E]|[\\uFB40-\\uFB41]|[\\uFB43-\\uFB44]|[\\uFB46-\\uFBB1]|[\\uFBD3-\\uFD3D]|[\\uFD50-\\uFD8F]|[\\uFD92-\\uFDC7]|[\\uFDF0-\\uFDFB]|[\\uFE70-\\uFE72]|[\\uFE74-\\uFE74]|[\\uFE76-\\uFEFC]|[\\uFF66-\\uFF6F]|[\\uFF71-\\uFF9D]|[\\uFFA0-\\uFFBE]|[\\uFFC2-\\uFFC7]|[\\uFFCA-\\uFFCF]|[\\uFFD2-\\uFFD7]|[\\uFFDA-\\uFFDC]/,\n  Ltmo: /[\\u01C5-\\u01C5]|[\\u01C8-\\u01C8]|[\\u01CB-\\u01CB]|[\\u01F2-\\u01F2][\\u02B0-\\u02B8]|[\\u02BB-\\u02C1]|[\\u02D0-\\u02D1]|[\\u02E0-\\u02E4]|[\\u037A-\\u037A]|[\\u0559-\\u0559]|[\\u0640-\\u0640]|[\\u06E5-\\u06E6]|[\\u0E46-\\u0E46]|[\\u0EC6-\\u0EC6]|[\\u3005-\\u3005]|[\\u3031-\\u3035]|[\\u309D-\\u309E]|[\\u30FC-\\u30FE]|[\\uFF70-\\uFF70]|[\\uFF9E-\\uFF9F][\\u01AA-\\u01AA]|[\\u01BB-\\u01BB]|[\\u01BE-\\u01C3]|[\\u03F3-\\u03F3]|[\\u04C0-\\u04C0]|[\\u05D0-\\u05EA]|[\\u05F0-\\u05F2]|[\\u0621-\\u063A]|[\\u0641-\\u064A]|[\\u0671-\\u06B7]|[\\u06BA-\\u06BE]|[\\u06C0-\\u06CE]|[\\u06D0-\\u06D3]|[\\u06D5-\\u06D5]|[\\u0905-\\u0939]|[\\u093D-\\u093D]|[\\u0950-\\u0950]|[\\u0958-\\u0961]|[\\u0985-\\u098C]|[\\u098F-\\u0990]|[\\u0993-\\u09A8]|[\\u09AA-\\u09B0]|[\\u09B2-\\u09B2]|[\\u09B6-\\u09B9]|[\\u09DC-\\u09DD]|[\\u09DF-\\u09E1]|[\\u09F0-\\u09F1]|[\\u0A05-\\u0A0A]|[\\u0A0F-\\u0A10]|[\\u0A13-\\u0A28]|[\\u0A2A-\\u0A30]|[\\u0A32-\\u0A33]|[\\u0A35-\\u0A36]|[\\u0A38-\\u0A39]|[\\u0A59-\\u0A5C]|[\\u0A5E-\\u0A5E]|[\\u0A72-\\u0A74]|[\\u0A85-\\u0A8B]|[\\u0A8D-\\u0A8D]|[\\u0A8F-\\u0A91]|[\\u0A93-\\u0AA8]|[\\u0AAA-\\u0AB0]|[\\u0AB2-\\u0AB3]|[\\u0AB5-\\u0AB9]|[\\u0ABD-\\u0ABD]|[\\u0AD0-\\u0AD0]|[\\u0AE0-\\u0AE0]|[\\u0B05-\\u0B0C]|[\\u0B0F-\\u0B10]|[\\u0B13-\\u0B28]|[\\u0B2A-\\u0B30]|[\\u0B32-\\u0B33]|[\\u0B36-\\u0B39]|[\\u0B3D-\\u0B3D]|[\\u0B5C-\\u0B5D]|[\\u0B5F-\\u0B61]|[\\u0B85-\\u0B8A]|[\\u0B8E-\\u0B90]|[\\u0B92-\\u0B95]|[\\u0B99-\\u0B9A]|[\\u0B9C-\\u0B9C]|[\\u0B9E-\\u0B9F]|[\\u0BA3-\\u0BA4]|[\\u0BA8-\\u0BAA]|[\\u0BAE-\\u0BB5]|[\\u0BB7-\\u0BB9]|[\\u0C05-\\u0C0C]|[\\u0C0E-\\u0C10]|[\\u0C12-\\u0C28]|[\\u0C2A-\\u0C33]|[\\u0C35-\\u0C39]|[\\u0C60-\\u0C61]|[\\u0C85-\\u0C8C]|[\\u0C8E-\\u0C90]|[\\u0C92-\\u0CA8]|[\\u0CAA-\\u0CB3]|[\\u0CB5-\\u0CB9]|[\\u0CDE-\\u0CDE]|[\\u0CE0-\\u0CE1]|[\\u0D05-\\u0D0C]|[\\u0D0E-\\u0D10]|[\\u0D12-\\u0D28]|[\\u0D2A-\\u0D39]|[\\u0D60-\\u0D61]|[\\u0E01-\\u0E30]|[\\u0E32-\\u0E33]|[\\u0E40-\\u0E45]|[\\u0E81-\\u0E82]|[\\u0E84-\\u0E84]|[\\u0E87-\\u0E88]|[\\u0E8A-\\u0E8A]|[\\u0E8D-\\u0E8D]|[\\u0E94-\\u0E97]|[\\u0E99-\\u0E9F]|[\\u0EA1-\\u0EA3]|[\\u0EA5-\\u0EA5]|[\\u0EA7-\\u0EA7]|[\\u0EAA-\\u0EAB]|[\\u0EAD-\\u0EB0]|[\\u0EB2-\\u0EB3]|[\\u0EBD-\\u0EBD]|[\\u0EC0-\\u0EC4]|[\\u0EDC-\\u0EDD]|[\\u0F00-\\u0F00]|[\\u0F40-\\u0F47]|[\\u0F49-\\u0F69]|[\\u0F88-\\u0F8B]|[\\u1100-\\u1159]|[\\u115F-\\u11A2]|[\\u11A8-\\u11F9]|[\\u2135-\\u2138]|[\\u3006-\\u3006]|[\\u3041-\\u3094]|[\\u30A1-\\u30FA]|[\\u3105-\\u312C]|[\\u3131-\\u318E]|[\\u4E00-\\u9FA5]|[\\uAC00-\\uD7A3]|[\\uF900-\\uFA2D]|[\\uFB1F-\\uFB28]|[\\uFB2A-\\uFB36]|[\\uFB38-\\uFB3C]|[\\uFB3E-\\uFB3E]|[\\uFB40-\\uFB41]|[\\uFB43-\\uFB44]|[\\uFB46-\\uFBB1]|[\\uFBD3-\\uFD3D]|[\\uFD50-\\uFD8F]|[\\uFD92-\\uFDC7]|[\\uFDF0-\\uFDFB]|[\\uFE70-\\uFE72]|[\\uFE74-\\uFE74]|[\\uFE76-\\uFEFC]|[\\uFF66-\\uFF6F]|[\\uFF71-\\uFF9D]|[\\uFFA0-\\uFFBE]|[\\uFFC2-\\uFFC7]|[\\uFFCA-\\uFFCF]|[\\uFFD2-\\uFFD7]|[\\uFFDA-\\uFFDC]/\n};\n","deps":{},"file":"/Users/dubroy/dev/cdg/ohm/third_party/UnicodeCategories.js","sourceRoot":"file://localhost","sourceFile":"third_party/UnicodeCategories.js"},"/Users/dubroy/dev/cdg/ohm/src/Grammar.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/Grammar.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar InputStream = require('./InputStream');\nvar Interval = require('./Interval');\nvar MatchResult = require('./MatchResult');\nvar Semantics = require('./Semantics');\nvar State = require('./State');\nvar common = require('./common');\nvar errors = require('./errors');\nvar nodes = require('./nodes');\nvar pexprs = require('./pexprs');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction Grammar(\n    name,\n    superGrammar,\n    ruleBodies,\n    ruleFormals,\n    ruleDescriptions,\n    optDefaultStartRule) {\n  this.name = name;\n  this.superGrammar = superGrammar;\n  this.ruleBodies = ruleBodies;\n  this.ruleFormals = ruleFormals;\n  this.ruleDescriptions = ruleDescriptions;\n  if (optDefaultStartRule) {\n    if (!(optDefaultStartRule in ruleBodies)) {\n      throw new Error(\"Invalid start rule: '\" + optDefaultStartRule +\n                      \"' is not a rule in grammar '\" + name + \"'\");\n    }\n    this.defaultStartRule = optDefaultStartRule;\n  }\n  this.constructors = this.ctors = this.createConstructors();\n}\n\nGrammar.prototype = {\n  construct: function(ruleName, children) {\n    var body = this.ruleBodies[ruleName];\n    if (!body || !body.check(this, children) || children.length !== body.getArity()) {\n      throw errors.invalidConstructorCall(this, ruleName, children);\n    }\n    var interval = new Interval(InputStream.newFor(children), 0, children.length);\n    return new nodes.Node(this, ruleName, children, interval);\n  },\n\n  createConstructors: function() {\n    var self = this;\n    var constructors = {};\n\n    function makeConstructor(ruleName) {\n      return function(/* val1, val2, ... */) {\n        return self.construct(ruleName, Array.prototype.slice.call(arguments));\n      };\n    }\n\n    for (var ruleName in this.ruleBodies) {\n      // We want *all* properties, not just own properties, because of\n      // supergrammars.\n      constructors[ruleName] = makeConstructor(ruleName);\n    }\n    return constructors;\n  },\n\n  // Return true if the grammar is a built-in grammar, otherwise false.\n  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!\n  isBuiltIn: function() {\n    return this === Grammar.ProtoBuiltInRules || this === Grammar.BuiltInRules;\n  },\n\n  match: function(obj, optStartRule) {\n    var startRule = optStartRule || this.defaultStartRule;\n    if (!startRule) {\n      throw new Error('Missing start rule argument -- the grammar has no default start rule.');\n    }\n    var state = this._match(obj, startRule, false);\n    return MatchResult.newFor(state);\n  },\n\n  _match: function(obj, startRule, tracingEnabled) {\n    var inputStream = InputStream.newFor(typeof obj === 'string' ? obj : [obj]);\n    var state = new State(this, inputStream, startRule, tracingEnabled);\n    state.eval(new pexprs.Apply(startRule));\n    return state;\n  },\n\n  trace: function(obj, optStartRule) {\n    var startRule = optStartRule || this.defaultStartRule;\n    if (!startRule) {\n      throw new Error('Missing start rule argument -- the grammar has no default start rule.');\n    }\n    var state = this._match(obj, startRule, true);\n\n    var rootTrace = state.trace[0];\n    rootTrace.state = state;\n    rootTrace.result = MatchResult.newFor(state);\n    return rootTrace;\n  },\n\n  semantics: function() {\n    return Semantics.createSemantics(this);\n  },\n\n  extendSemantics: function(superSemantics) {\n    return Semantics.createSemantics(this, superSemantics._getSemantics());\n  },\n\n  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to\n  // a function of the correct arity. If not, throw an exception.\n  _checkTopDownActionDict: function(what, name, actionDict) {\n    function isSpecialAction(a) {\n      return a === '_iter' || a === '_terminal' || a === '_nonterminal' || a === '_default';\n    }\n\n    var problems = [];\n    for (var k in actionDict) {\n      var v = actionDict[k];\n      if (!isSpecialAction(k) && !(k in this.ruleBodies)) {\n        problems.push(\"'\" + k + \"' is not a valid semantic action for '\" + this.name + \"'\");\n      } else if (typeof v !== 'function') {\n        problems.push(\n            \"'\" + k + \"' must be a function in an action dictionary for '\" + this.name + \"'\");\n      } else {\n        var actual = v.length;\n        var expected = this._topDownActionArity(k);\n        if (actual !== expected) {\n          problems.push(\n              \"Semantic action '\" + k + \"' has the wrong arity: \" +\n              'expected ' + expected + ', got ' + actual);\n        }\n      }\n    }\n    if (problems.length > 0) {\n      var prettyProblems = problems.map(function(problem) { return '- ' + problem; });\n      var error = new Error(\n          \"Found errors in the action dictionary of the '\" + name + \"' \" + what + ':\\n' +\n          prettyProblems.join('\\n'));\n      error.problems = problems;\n      throw error;\n    }\n  },\n\n  // Return the expected arity for a semantic action named `actionName`, which\n  // is either a rule name or a special action name like '_nonterminal'.\n  _topDownActionArity: function(actionName) {\n    if (actionName === '_iter' || actionName === '_nonterminal' || actionName === '_default') {\n      return 1;\n    } else if (actionName === '_terminal') {\n      return 0;\n    }\n    return this.ruleBodies[actionName].getArity();\n  },\n\n  _inheritsFrom: function(grammar) {\n    var g = this.superGrammar;\n    while (g) {\n      if (g === grammar) {\n        return true;\n      }\n      g = g.superGrammar;\n    }\n    return false;\n  },\n\n  toRecipe: function(optVarName) {\n    if (this.isBuiltIn()) {\n      throw new Error(\n          'Why would anyone want to generate a recipe for the ' + this.name + ' grammar?!?!');\n    }\n\n    var sb = new common.StringBuffer();\n    if (optVarName) {\n      sb.append('var ' + optVarName + ' = ');\n    }\n    sb.append('(function() {\\n');\n\n    // Include the supergrammar in the recipe if it's not a built-in grammar.\n    var superGrammarDecl = '';\n    if (!this.superGrammar.isBuiltIn()) {\n      sb.append(this.superGrammar.toRecipe('buildSuperGrammar'));\n      superGrammarDecl = '    .withSuperGrammar(buildSuperGrammar.call(this))\\n';\n    }\n    sb.append('  return new this.newGrammar(' + JSON.stringify(this.name) + ')\\n');\n    sb.append(superGrammarDecl);\n\n    if (this.defaultStartRule) {\n      sb.append(\"    .withDefaultStartRule('\" + this.defaultStartRule + \"')\\n\");\n    }\n\n    var self = this;\n    Object.keys(this.ruleBodies).forEach(function(ruleName) {\n      var body = self.ruleBodies[ruleName];\n      sb.append('    .');\n      if (self.superGrammar.ruleBodies[ruleName]) {\n        sb.append(body instanceof pexprs.Extend ? 'extend' : 'override');\n      } else {\n        sb.append('define');\n      }\n      var formals = self.ruleFormals[ruleName];\n      var formalsString = '[' + formals.map(JSON.stringify).join(', ') + ']';\n      sb.append('(' + JSON.stringify(ruleName) + ', ' + formalsString + ', ');\n      body.outputRecipe(sb, formals);\n      if (!self.superGrammar.ruleBodies[ruleName] && self.ruleDescriptions[ruleName]) {\n        sb.append(', ' + JSON.stringify(self.ruleDescriptions[ruleName]));\n      }\n      sb.append(')\\n');\n    });\n    sb.append('    .build();\\n});\\n');\n    return sb.contents();\n  },\n\n  // TODO: Come up with better names for these methods.\n  // TODO: Write the analog of these methods for inherited attributes.\n  toOperationActionDictionaryTemplate: function() {\n    return this._toOperationOrAttributeActionDictionaryTemplate();\n  },\n  toAttributeActionDictionaryTemplate: function() {\n    return this._toOperationOrAttributeActionDictionaryTemplate();\n  },\n\n  _toOperationOrAttributeActionDictionaryTemplate: function() {\n    // TODO: add the super-grammar's templates at the right place, e.g., a case for AddExpr_plus\n    // should appear next to other cases of AddExpr.\n\n    var sb = new common.StringBuffer();\n    sb.append('{');\n\n    var first = true;\n    for (var ruleName in this.ruleBodies) {\n      if (ruleName === 'spaces_') {\n        // This rule is not for the user, it's more of an implementation detail of syntactic rules.\n        continue;\n      }\n      var body = this.ruleBodies[ruleName];\n      if (first) {\n        first = false;\n      } else {\n        sb.append(',');\n      }\n      sb.append('\\n');\n      sb.append('  ');\n      this.addSemanticActionTemplate(ruleName, body, sb);\n    }\n\n    sb.append('\\n}');\n    return sb.contents();\n  },\n\n  addSemanticActionTemplate: function(ruleName, body, sb) {\n    sb.append(ruleName);\n    sb.append(': function(');\n    var arity = this._topDownActionArity(ruleName);\n    sb.append(common.repeat('_', arity).join(', '));\n    sb.append(') {\\n');\n    sb.append('  }');\n  }\n};\n\n// The following grammar contains a few rules that couldn't be written  in \"userland\".\n// At the bottom of src/main.js, we create a sub-grammar of this grammar that's called\n// `BuiltInRules`. That grammar contains several convenience rules, e.g., `letter` and\n// `digit`, and is implicitly the super-grammar of any grammar whose super-grammar\n// isn't specified.\nGrammar.ProtoBuiltInRules = new Grammar(\n    'ProtoBuiltInRules',  // name\n    undefined,  // supergrammar\n\n    // rule bodies\n    {\n      // The following rules can't be written in userland because they reference\n      // `any` and `end` directly.\n      any: pexprs.any,\n      end: pexprs.end,\n\n      // The following rule is part of the Ohm implementation. Its name ends with '_' to\n      // discourage programmers from invoking, extending, and overriding it.\n      spaces_: new pexprs.Star(new pexprs.Apply('space')),\n\n      // The `space` rule must be defined here because it's referenced by `spaces_`.\n      space: new pexprs.Range('\\x00', ' '),\n\n      // These rules are implemented natively because they use UnicodeChar directly, which is\n      // not part of the Ohm grammar.\n      lower: new pexprs.UnicodeChar('Ll'),\n      upper: new pexprs.UnicodeChar('Lu'),\n\n      // The union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not\n      // in Ll or Lu.\n      unicodeLtmo: new pexprs.UnicodeChar('Ltmo')\n    },\n\n    // rule formal arguments\n    {\n      any: [],\n      end: [],\n      spaces_: [],\n      space: [],\n      lower: [],\n      upper: [],\n      unicodeLtmo: []\n    },\n\n    // rule descriptions\n    {\n      any: 'any object',\n      end: 'end of input',\n      space: 'a space',\n      lower: 'a lowercase letter',\n      upper: 'an uppercase letter'\n    }\n);\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = Grammar;\n","deps":{"./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./Semantics":"/Users/dubroy/dev/cdg/ohm/src/Semantics.js","./errors":"/Users/dubroy/dev/cdg/ohm/src/errors.js","./pexprs":"/Users/dubroy/dev/cdg/ohm/src/pexprs.js","./InputStream":"/Users/dubroy/dev/cdg/ohm/src/InputStream.js","./Interval":"/Users/dubroy/dev/cdg/ohm/src/Interval.js","./State":"/Users/dubroy/dev/cdg/ohm/src/State.js","./MatchResult":"/Users/dubroy/dev/cdg/ohm/src/MatchResult.js","./nodes":"/Users/dubroy/dev/cdg/ohm/src/nodes.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/Grammar.js","sourceRoot":"file://localhost","sourceFile":"src/Grammar.js"},"/Users/dubroy/dev/cdg/ohm/src/main.js":{"entry":true,"expose":false,"file":"/Users/dubroy/dev/cdg/ohm/src/main.js","id":"/Users/dubroy/dev/cdg/ohm/src/main.js","order":0,"source":"/* global document, XMLHttpRequest */\n\n'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar Builder = require('./Builder');\nvar Grammar = require('./Grammar');\nvar Namespace = require('./Namespace');\nvar common = require('./common');\nvar errors = require('./errors');\nvar util = require('./util');\n\nvar isBuffer = require('is-buffer');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// The metagrammar, i.e. the grammar for Ohm grammars. Initialized at the\n// bottom of this file because loading the grammar requires Ohm itself.\nvar ohmGrammar;\n\n// An object which makes it possible to stub out the document API for testing.\nvar documentInterface = {\n  querySelector: function(sel) { return document.querySelector(sel); },\n  querySelectorAll: function(sel) { return document.querySelectorAll(sel); }\n};\n\n// Check if `obj` is a DOM element.\nfunction isElement(obj) {\n  return !!(obj && obj.nodeType === 1);\n}\n\nfunction isUndefined(obj) {\n  return obj === void 0;\n}\n\nvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\nfunction isArrayLike(obj) {\n  if (obj == null) {\n    return false;\n  }\n  var length = obj.length;\n  return typeof length === 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n}\n\n// TODO: just use the jQuery thing\nfunction load(url) {\n  var req = new XMLHttpRequest();\n  req.open('GET', url, false);\n  try {\n    req.send();\n    if (req.status === 0 || req.status === 200) {\n      return req.responseText;\n    }\n  } catch (e) {}\n  throw new Error('unable to load url ' + url);\n}\n\n// Returns a Grammar instance (i.e., an object with a `match` method) for\n// `tree`, which is the concrete syntax tree of a user-written grammar.\n// The grammar will be assigned into `namespace` under the name of the grammar\n// as specified in the source.\nfunction buildGrammar(match, namespace, optOhmGrammarForTesting) {\n  var builder;\n  var decl;\n  var currentRuleName;\n  var currentRuleFormals;\n  var overriding = false;\n  var metaGrammar = optOhmGrammarForTesting || ohmGrammar;\n\n  // A visitor that produces a Grammar instance from the CST.\n  var helpers = metaGrammar.semantics().addOperation('visit', {\n    Grammar: function(n, s, open, rs, close) {\n      builder = new Builder();\n      var grammarName = n.visit();\n      decl = builder.newGrammar(grammarName, namespace);\n      s.visit();\n      rs.visit();\n      var g = decl.build();\n      g.definitionInterval = this.interval.trimmed();\n      if (grammarName in namespace) {\n        throw errors.duplicateGrammarDeclaration(g, namespace);\n      }\n      namespace[grammarName] = g;\n      return g;\n    },\n\n    SuperGrammar: function(_, n) {\n      var superGrammarName = n.visit();\n      if (superGrammarName === 'null') {\n        decl.withSuperGrammar(null);\n      } else {\n        if (!namespace || !(superGrammarName in namespace)) {\n          throw errors.undeclaredGrammar(superGrammarName, namespace, n.interval);\n        }\n        decl.withSuperGrammar(namespace[superGrammarName]);\n      }\n    },\n\n    Rule_define: function(n, fs, d, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.visit()[0] || [];\n      // If there is no default start rule yet, set it now. This must be done before visiting\n      // the body, because it might contain an inline rule definition.\n      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {\n        decl.withDefaultStartRule(currentRuleName);\n      }\n      var body = b.visit();\n      body.definitionInterval = this.interval.trimmed();\n      var description = d.visit()[0];\n      return decl.define(currentRuleName, currentRuleFormals, body, description);\n    },\n    Rule_override: function(n, fs, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.visit()[0] || [];\n      overriding = true;\n      var body = b.visit();\n      body.definitionInterval = this.interval.trimmed();\n      var ans = decl.override(currentRuleName, currentRuleFormals, body);\n      overriding = false;\n      return ans;\n    },\n    Rule_extend: function(n, fs, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.visit()[0] || [];\n      var body = b.visit();\n      var ans = decl.extend(currentRuleName, currentRuleFormals, body);\n      decl.ruleBodies[currentRuleName].definitionInterval = this.interval.trimmed();\n      return ans;\n    },\n\n    Formals: function(opointy, fs, cpointy) {\n      return fs.visit();\n    },\n\n    Params: function(opointy, ps, cpointy) {\n      return ps.visit();\n    },\n\n    Alt: function(term, _, terms) {\n      var args = [term.visit()].concat(terms.visit());\n      return builder.alt.apply(builder, args).withInterval(this.interval);\n    },\n\n    Term_inline: function(b, n) {\n      var inlineRuleName = currentRuleName + '_' + n.visit();\n      var body = b.visit();\n      body.definitionInterval = this.interval.trimmed();\n      var isNewRuleDeclaration =\n          !(decl.superGrammar && decl.superGrammar.ruleBodies[inlineRuleName]);\n      if (overriding && !isNewRuleDeclaration) {\n        decl.override(inlineRuleName, currentRuleFormals, body);\n      } else {\n        decl.define(inlineRuleName, currentRuleFormals, body);\n      }\n      var params = currentRuleFormals.map(function(formal) { return builder.app(formal); });\n      return builder.app(inlineRuleName, params).withInterval(body.interval);\n    },\n\n    Seq: function(expr) {\n      return builder.seq.apply(builder, expr.visit()).withInterval(this.interval);\n    },\n\n    Iter_star: function(x, _) {\n      return builder.star(x.visit()).withInterval(this.interval);\n    },\n    Iter_plus: function(x, _) {\n      return builder.plus(x.visit()).withInterval(this.interval);\n    },\n    Iter_opt: function(x, _) {\n      return builder.opt(x.visit()).withInterval(this.interval);\n    },\n\n    Pred_not: function(_, x) {\n      return builder.not(x.visit()).withInterval(this.interval);\n    },\n    Pred_lookahead: function(_, x) {\n      return builder.la(x.visit()).withInterval(this.interval);\n    },\n\n    Lex_lex: function(_, x) {\n      return builder.lex(x.visit()).withInterval(this.interval);\n    },\n\n    Base_application: function(rule, ps) {\n      return builder.app(rule.visit(), ps.visit()[0] || []).withInterval(this.interval);\n    },\n    Base_range: function(from, _, to) {\n      return builder.range(from.visit(), to.visit()).withInterval(this.interval);\n    },\n    Base_prim: function(expr) {\n      return builder.prim(expr.visit()).withInterval(this.interval);\n    },\n    Base_paren: function(open, x, close) {\n      return x.visit();\n    },\n    Base_arr: function(open, x, close) {\n      return builder.arr(x.visit()).withInterval(this.interval);\n    },\n    Base_str: function(open, x, close) {\n      return builder.str(x.visit());\n    },\n    Base_obj: function(open, lenient, close) {\n      return builder.obj([], lenient.visit()[0]);\n    },\n\n    Base_objWithProps: function(open, ps, _, lenient, close) {\n      return builder.obj(ps.visit(), lenient.visit()[0]).withInterval(this.interval);\n    },\n\n    Props: function(p, _, ps) {\n      return [p.visit()].concat(ps.visit());\n    },\n    Prop: function(n, _, p) {\n      return {name: n.visit(), pattern: p.visit()};\n    },\n\n    ruleDescr: function(open, t, close) {\n      return t.visit();\n    },\n    ruleDescrText: function(_) {\n      return this.interval.contents.trim();\n    },\n\n    caseName: function(_, space1, n, space2, end) {\n      return n.visit();\n    },\n\n    name: function(first, rest) {\n      return this.interval.contents;\n    },\n    nameFirst: function(expr) {},\n    nameRest: function(expr) {},\n\n    keyword_null: function(_) {\n      return null;\n    },\n    keyword_true: function(_) {\n      return true;\n    },\n    keyword_false: function(_) {\n      return false;\n    },\n\n    string: function(open, cs, close) {\n      return cs.visit().map(function(c) { return common.unescapeChar(c); }).join('');\n    },\n\n    strChar: function(_) {\n      return this.interval.contents;\n    },\n\n    escapeChar: function(_) {\n      return this.interval.contents;\n    },\n\n    number: function(_, digits) {\n      return parseInt(this.interval.contents);\n    },\n\n    space: function(expr) {},\n    space_multiLine: function(start, _, end) {},\n    space_singleLine: function(start, _, end) {},\n\n    ListOf_some: function(x, _, xs) {\n      return [x.visit()].concat(xs.visit());\n    },\n    ListOf_none: function() {\n      return [];\n    }\n  });\n  return helpers(match).visit();\n}\n\nfunction compileAndLoad(source, namespace) {\n  var m = ohmGrammar.match(source, 'Grammars');\n  if (m.failed()) {\n    throw errors.grammarSyntaxError(m);\n  }\n  return buildGrammar(m, namespace);\n}\n\n// Return the contents of a script element, fetching it via XHR if necessary.\nfunction getScriptElementContents(el) {\n  if (!isElement(el)) {\n    throw new TypeError('Expected a DOM Node, got ' + common.unexpectedObjToString(el));\n  }\n  if (el.type !== 'text/ohm-js') {\n    throw new Error('Expected a script tag with type=\"text/ohm-js\", got ' + el);\n  }\n  return el.getAttribute('src') ? load(el.getAttribute('src')) : el.innerHTML;\n}\n\nfunction grammar(source, optNamespace) {\n  var ns = grammars(source, optNamespace);\n\n  // Ensure that the source contained no more than one grammar definition.\n  var grammarNames = Object.keys(ns);\n  if (grammarNames.length === 0) {\n    throw new Error('Missing grammar definition');\n  } else if (grammarNames.length > 1) {\n    var secondGrammar = ns[grammarNames[1]];\n    var interval = secondGrammar.definitionInterval;\n    throw new Error(\n        util.getLineAndColumnMessage(interval.inputStream.source, interval.startIdx) +\n        'Found more than one grammar definition -- use ohm.grammars() instead.');\n  }\n  return ns[grammarNames[0]];  // Return the one and only grammar.\n}\n\nfunction grammars(source, optNamespace) {\n  var ns = Namespace.extend(Namespace.asNamespace(optNamespace));\n  if (typeof source !== 'string') {\n    // For convenience, detect Node.js Buffer objects and automatically call toString().\n    if (isBuffer(source)) {\n      source = source.toString();\n    } else {\n      throw new TypeError(\n          'Expected string as first argument, got ' + common.unexpectedObjToString(source));\n    }\n  }\n  compileAndLoad(source, ns);\n  return ns;\n}\n\nfunction grammarFromScriptElement(optNode) {\n  var node = optNode;\n  if (isUndefined(node)) {\n    var nodeList = documentInterface.querySelectorAll('script[type=\"text/ohm-js\"]');\n    if (nodeList.length !== 1) {\n      throw new Error(\n          'Expected exactly one script tag with type=\"text/ohm-js\", found ' + nodeList.length);\n    }\n    node = nodeList[0];\n  }\n  return grammar(getScriptElementContents(node));\n}\n\nfunction grammarsFromScriptElements(optNodeOrNodeList) {\n  // Simple case: the argument is a DOM node.\n  if (isElement(optNodeOrNodeList)) {\n    return grammars(optNodeOrNodeList);\n  }\n  // Otherwise, it must be either undefined or a NodeList.\n  var nodeList = optNodeOrNodeList;\n  if (isUndefined(nodeList)) {\n    // Find all script elements with type=\"text/ohm-js\".\n    nodeList = documentInterface.querySelectorAll('script[type=\"text/ohm-js\"]');\n  } else if (typeof nodeList === 'string' || (!isElement(nodeList) && !isArrayLike(nodeList))) {\n    throw new TypeError('Expected a Node, NodeList, or Array, but got ' + nodeList);\n  }\n  var ns = Namespace.createNamespace();\n  for (var i = 0; i < nodeList.length; ++i) {\n    // Copy the new grammars into `ns` to keep the namespace flat.\n    common.extend(ns, grammars(getScriptElementContents(nodeList[i]), ns));\n  }\n  return ns;\n}\n\nfunction makeRecipe(recipeFn) {\n  return recipeFn.call(new Builder());\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\n// Stuff that users should know about\n\nmodule.exports = {\n  createNamespace: Namespace.createNamespace,\n  grammar: grammar,\n  grammars: grammars,\n  grammarFromScriptElement: grammarFromScriptElement,\n  grammarsFromScriptElements: grammarsFromScriptElements,\n  makeRecipe: makeRecipe,\n  util: util\n};\n\n// Stuff that's only here for bootstrapping, testing, etc.\n\nGrammar.BuiltInRules = require('../dist/built-in-rules');\n\nvar Semantics = require('./Semantics');\nvar operationsAndAttributesGrammar = require('../dist/operations-and-attributes');\nSemantics.initPrototypeParser(operationsAndAttributesGrammar);\n\nohmGrammar = require('../dist/ohm-grammar');\nmodule.exports._buildGrammar = buildGrammar;\nmodule.exports._setDocumentInterfaceForTesting = function(doc) { documentInterface = doc; };\nmodule.exports.ohmGrammar = ohmGrammar;\n","deps":{"./errors":"/Users/dubroy/dev/cdg/ohm/src/errors.js","./util":"/Users/dubroy/dev/cdg/ohm/src/util.js","../dist/ohm-grammar":"/Users/dubroy/dev/cdg/ohm/dist/ohm-grammar.js","../dist/built-in-rules":"/Users/dubroy/dev/cdg/ohm/dist/built-in-rules.js","../dist/operations-and-attributes":"/Users/dubroy/dev/cdg/ohm/dist/operations-and-attributes.js","is-buffer":"/Users/dubroy/dev/cdg/ohm/node_modules/is-buffer/index.js","./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","./Namespace":"/Users/dubroy/dev/cdg/ohm/src/Namespace.js","./Builder":"/Users/dubroy/dev/cdg/ohm/src/Builder.js","./Grammar":"/Users/dubroy/dev/cdg/ohm/src/Grammar.js","./Semantics":"/Users/dubroy/dev/cdg/ohm/src/Semantics.js"},"sourceRoot":"file://localhost","sourceFile":"src/main.js"},"/Users/dubroy/dev/cdg/ohm/src/Semantics.js":{"id":"/Users/dubroy/dev/cdg/ohm/src/Semantics.js","source":"'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nvar Symbol = require('es6-symbol');  // eslint-disable-line no-undef\nvar inherits = require('inherits');\n\nvar MatchResult = require('./MatchResult');\nvar common = require('./common');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// ----------------- Wrappers -----------------\n\n// Wrappers decorate CST nodes with all of the functionality (i.e., operations and attributes)\n// provided by a Semantics (see below). `Wrapper` is the abstract superclass of all wrappers. A\n// `Wrapper` must have `_node` and `_semantics` instance variables, which refer to the CST node and\n// Semantics (resp.) for which it was created, and a `_childWrappers` instance variable which is\n// used to cache the wrapper instances that are created for its child nodes. Setting these instance\n// variables is the responsibility of the constructor of each Semantics-specific subclass of\n// `Wrapper`.\nfunction Wrapper() {}\n\nWrapper.prototype.toString = function() {\n  return '[semantics wrapper for ' + this._node.grammar.name + ']';\n};\n\n// Returns the wrapper of the specified child node. Child wrappers are created lazily and cached in\n// the parent wrapper's `_childWrappers` instance variable.\nWrapper.prototype.child = function(idx) {\n  if (!(0 <= idx && idx < this._node.numChildren())) {\n    // TODO: Consider throwing an exception here.\n    return undefined;\n  }\n  var childWrapper = this._childWrappers[idx];\n  if (!childWrapper) {\n    childWrapper = this._childWrappers[idx] = this._semantics.wrap(this._node.childAt(idx));\n  }\n  return childWrapper;\n};\n\n// Returns an array containing the wrappers of all of the children of the node associated with this\n// wrapper.\nWrapper.prototype._children = function() {\n  // Force the creation of all child wrappers\n  for (var idx = 0; idx < this._node.numChildren(); idx++) {\n    this.child(idx);\n  }\n  return this._childWrappers;\n};\n\n// Returns `true` if the CST node associated with this wrapper corresponds to an iteration\n// expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.\nWrapper.prototype.isIteration = function() {\n  return this._node.ctorName === '_iter';\n};\n\n// Returns `true` if the CST node associated with this wrapper is a terminal node, `false`\n// otherwise.\nWrapper.prototype.isTerminal = function() {\n  return this._node.isTerminal();\n};\n\n// Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`\n// otherwise.\nWrapper.prototype.isNonterminal = function() {\n  return !this.isTerminal() && !this.isIteration();\n};\n\nObject.defineProperties(Wrapper.prototype, {\n  // Returns an array containing the children of this CST node.\n  children: {get: function() { return this._children(); }},\n\n  // Returns the name of grammar rule that created this CST node.\n  ctorName: {get: function() { return this._node.ctorName; }},\n\n  // Returns the interval consumed by the CST node associated with this wrapper.\n  interval: {get: function() { return this._node.interval; }},\n\n  // Returns the number of children of this CST node.\n  numChildren: {get: function() { return this._node.numChildren(); }},\n\n  // Returns the primitive value of this CST node, if it's a terminal node. Otherwise,\n  // throws an exception.\n  primitiveValue: {\n    get: function() {\n      if (this.isTerminal()) {\n        return this._node.primitiveValue;\n      }\n      throw new TypeError(\n          \"tried to access the 'primitiveValue' attribute of a non-terminal CST node\");\n    }\n  }\n});\n\n// ----------------- Semantics -----------------\n\n// A Semantics is a container for a family of Operations and Attributes for a given grammar.\n// Semantics enable modularity (different clients of a grammar can create their set of operations\n// and attributes in isolation) and extensibility even when operations and attributes are mutually-\n// recursive. This constructor should not be called directly except from\n// `Semantics.createSemantics`. The normal ways to create a Semantics, given a grammar 'g', are\n// `g.semantics()` and `g.extendSemantics(parentSemantics)`.\nfunction Semantics(grammar, optSuperSemantics) {\n  var self = this;\n  this.grammar = grammar;\n  this.checkedActionDicts = false;\n\n  // Constructor for wrapper instances, which are passed as the arguments to the semantic actions\n  // of an operation or attribute. Operations and attributes require double dispatch: the semantic\n  // action is chosen based on both the node's type and the semantics. Wrappers ensure that\n  // the `execute` method is called with the correct (most specific) semantics object as an\n  // argument.\n  this.Wrapper = function(node) {\n    self.checkActionDictsIfHaventAlready();\n    this._semantics = self;\n    this._node = node;\n    this._childWrappers = [];\n  };\n\n  if (optSuperSemantics) {\n    this.super = optSuperSemantics;\n    if (grammar !== this.super.grammar && !grammar._inheritsFrom(this.super.grammar)) {\n      throw new Error(\n          \"Cannot extend a semantics for grammar '\" + this.super.grammar.name +\n          \"' for use with grammar '\" + grammar.name + \"' (not a sub-grammar)\");\n    }\n    inherits(this.Wrapper, this.super.Wrapper);\n    this.operations = Object.create(this.super.operations);\n    this.attributes = Object.create(this.super.attributes);\n    this.attributeKeys = Object.create(null);\n\n    // Assign unique symbols for each of the attributes inherited from the super-semantics so that\n    // they are memoized independently.\n    for (var attributeName in this.attributes) {\n      this.attributeKeys[attributeName] = Symbol();\n    }\n  } else {\n    inherits(this.Wrapper, Wrapper);\n    this.operations = Object.create(null);\n    this.attributes = Object.create(null);\n    this.attributeKeys = Object.create(null);\n  }\n}\n\nSemantics.prototype.toString = function() {\n  return '[semantics for ' + this.grammar.name + ']';\n};\n\nSemantics.prototype.checkActionDictsIfHaventAlready = function() {\n  if (!this.checkedActionDicts) {\n    this.checkActionDicts();\n    this.checkedActionDicts = true;\n  }\n};\n\n// Checks that the action dictionaries for all operations and attributes in this semantics,\n// including the ones that were inherited from the super-semantics, agree with the grammar.\n// Throws an exception if one or more of them doesn't.\nSemantics.prototype.checkActionDicts = function() {\n  for (var name in this.operations) {\n    this.operations[name].checkActionDict(this.grammar);\n  }\n  for (name in this.attributes) {\n    this.attributes[name].checkActionDict(this.grammar);\n  }\n};\n\nvar prototypeGrammar;\nvar prototypeGrammarSemantics;\n\n// This method is called from main.js once Ohm has loaded.\nSemantics.initPrototypeParser = function(grammar) {\n  prototypeGrammarSemantics = grammar.semantics().addOperation('parse', {\n    NameNoFormals: function(n) {\n      return {\n        name: n.parse(),\n        formals: []\n      };\n    },\n    NameAndFormals: function(n, fs) {\n      return {\n        name: n.parse(),\n        formals: fs.parse()[0] || []\n      };\n    },\n    Formals: function(oparen, fs, cparen) {\n      return fs.parse();\n    },\n    name: function(first, rest) {\n      return this.interval.contents;\n    },\n    ListOf_none: function() {\n      return [];\n    },\n    ListOf_some: function(x, _, xs) {\n      return [x.parse()].concat(xs.parse());\n    }\n  });\n  prototypeGrammar = grammar;\n};\n\nfunction parsePrototype(nameAndFormalArgs, allowFormals) {\n  if (!prototypeGrammar) {\n    // The Operations and Attributes grammar won't be available while Ohm is loading,\n    // but we can get away the following simplification b/c none of the operations\n    // that are used while loading take arguments.\n    return {\n      name: nameAndFormalArgs,\n      formals: []\n    };\n  }\n\n  var r = prototypeGrammar.match(\n      nameAndFormalArgs,\n      allowFormals ? 'NameAndFormals' : 'NameNoFormals');\n  if (r.failed()) {\n    throw new Error(r.message);\n  }\n\n  return prototypeGrammarSemantics(r).parse();\n}\n\nSemantics.prototype.addOperationOrAttribute = function(type, nameAndFormalArgs, actionDict) {\n  var typePlural = type + 's';\n\n  var parsedNameAndFormalArgs = parsePrototype(nameAndFormalArgs, type === 'operation');\n  var name = parsedNameAndFormalArgs.name;\n  var formals = parsedNameAndFormalArgs.formals;\n\n  // TODO: check that there are no duplicate formal arguments\n\n  this.assertNewName(name, type);\n\n  // Create the action dictionary for this operation / attribute that contains a `_default` action\n  // which defines the default behavior of iteration, terminal, and non-terminal nodes...\n  var realActionDict = {\n    _default: function(children) {\n      var self = this;\n      var thisThing = this._semantics[typePlural][name];\n      var args = thisThing.formals.map(function(formal) {\n        return self.args[formal];\n      });\n\n      if (this.isIteration()) {\n        // This CST node corresponds to an iteration expression in the grammar (*, +, or ?). The\n        // default behavior is to map this operation or attribute over all of its child nodes.\n        return children.map(function(child) { return doIt.apply(child, args); });\n      }\n\n      if (this.isTerminal()) {\n        // This CST node corresponds to a terminal expression in the grammar (e.g., \"+\"). The\n        // default behavior is to return that terminal's primitive value.\n        return this.primitiveValue;\n      }\n\n      // This CST node corresponds to a non-terminal in the grammar (e.g., AddExpr). The fact that\n      // we got here means that this action dictionary doesn't have an action for this particular\n      // non-terminal or a generic `_nonterminal` action.\n      if (children.length === 1) {\n        // As a convenience, if this node only has one child, we just return the result of\n        // applying this operation / attribute to the child node.\n        return doIt.apply(children[0], args);\n      } else {\n        // Otherwise, we throw an exception to let the programmer know that we don't know what\n        // to do with this node.\n        throw new Error(\n            'Missing semantic action for ' + this.ctorName + ' in ' + name + ' ' + type);\n      }\n    }\n  };\n  // ... and add in the actions supplied by the programmer, which may override some or all of the\n  // default ones.\n  Object.keys(actionDict).forEach(function(name) {\n    realActionDict[name] = actionDict[name];\n  });\n\n  this[typePlural][name] = type === 'operation' ?\n      new Operation(name, formals, realActionDict) :\n      new Attribute(name, realActionDict);\n\n  // The following check is not strictly necessary (it will happen later anyway) but it's better to\n  // catch errors early.\n  this[typePlural][name].checkActionDict(this.grammar);\n\n  function doIt() {\n    // Dispatch to most specific version of this operation / attribute -- it may have been\n    // overridden by a sub-semantics.\n    var thisThing = this._semantics[typePlural][name];\n\n    // Check that the caller passed the correct number of arguments.\n    if (arguments.length !== thisThing.formals.length) {\n      throw new Error(\n          'Invalid number of arguments passed to ' + name + ' ' + type + ' (expected ' +\n          thisThing.formals.length + ', got ' + arguments.length + ')');\n    }\n\n    // Create an \"arguments object\" from the arguments that were passed to this\n    // operation / attribute.\n    var args = Object.create(null);\n    for (var idx = 0; idx < arguments.length; idx++) {\n      var formal = thisThing.formals[idx];\n      args[formal] = arguments[idx];\n    }\n\n    var oldArgs = this.args;\n    this.args = args;\n    var ans = thisThing.execute(this._semantics, this);\n    this.args = oldArgs;\n    return ans;\n  }\n\n  if (type === 'operation') {\n    this.Wrapper.prototype[name] = doIt;\n    this.Wrapper.prototype[name].toString = function() {\n      return '[' + name + ' operation]';\n    };\n  } else {\n    Object.defineProperty(this.Wrapper.prototype, name, {get: doIt});\n    this.attributeKeys[name] = Symbol();\n  }\n};\n\nSemantics.prototype.extendOperationOrAttribute = function(type, name, actionDict) {\n  var typePlural = type + 's';\n\n  // Make sure that `name` really is just a name, i.e., that it doesn't also contain formals.\n  parsePrototype(name, false);\n\n  if (!(this.super && name in this.super[typePlural])) {\n    throw new Error('Cannot extend ' + type + \" '\" + name +\n        \"': did not inherit an \" + type + ' with that name');\n  }\n  if (Object.prototype.hasOwnProperty.call(this[typePlural], name)) {\n    throw new Error('Cannot extend ' + type + \" '\" + name + \"' again\");\n  }\n\n  // Create a new operation / attribute whose actionDict delegates to the super operation /\n  // attribute's actionDict, and which has all the keys from `inheritedActionDict`.\n  var inheritedFormals = this[typePlural][name].formals;\n  var inheritedActionDict = this[typePlural][name].actionDict;\n  var newActionDict = Object.create(inheritedActionDict);\n  Object.keys(actionDict).forEach(function(name) {\n    newActionDict[name] = actionDict[name];\n  });\n\n  this[typePlural][name] = type === 'operation' ?\n      new Operation(name, inheritedFormals, newActionDict) :\n      new Attribute(name, newActionDict);\n\n  // The following check is not strictly necessary (it will happen later anyway) but it's better to\n  // catch errors early.\n  this[typePlural][name].checkActionDict(this.grammar);\n};\n\nSemantics.prototype.assertNewName = function(name, type) {\n  if (Wrapper.prototype.hasOwnProperty(name)) {\n    throw new Error(\n        'Cannot add ' + type + \" '\" + name + \"': that's a reserved name\");\n  }\n  if (name in this.operations) {\n    throw new Error(\n        'Cannot add ' + type + \" '\" + name + \"': an operation with that name already exists\");\n  }\n  if (name in this.attributes) {\n    throw new Error(\n        'Cannot add ' + type + \" '\" + name + \"': an attribute with that name already exists\");\n  }\n};\n\n// Returns a wrapper for the given CST `node` in this semantics.\nSemantics.prototype.wrap = function(node) {\n  return new this.Wrapper(node);\n};\n\n// Creates a new Semantics instance for `grammar`, inheriting operations and attributes from\n// `optSuperSemantics`, if it is specified. Returns a function that acts as a proxy for the new\n// Semantics instance. When that function is invoked with a CST node as an argument, it returns\n// a wrapper for that node which gives access to the operations and attributes provided by this\n// semantics.\nSemantics.createSemantics = function(grammar, optSuperSemantics) {\n  var s = new Semantics(grammar, optSuperSemantics);\n\n  // To enable clients to invoke a semantics like a function, return a function that acts as a proxy\n  // for `s`, which is the real `Semantics` instance.\n  var proxy = function ASemantics(matchResult) {\n    if (!(matchResult instanceof MatchResult)) {\n      throw new TypeError(\n          'Semantics expected a MatchResult, but got ' + common.unexpectedObjToString(matchResult));\n    }\n    if (!matchResult.succeeded()) {\n      throw new TypeError(\n          'cannot apply Semantics to ' + matchResult.toString());\n    }\n\n    var cst = matchResult._cst;\n    if (cst.grammar !== grammar) {\n      throw new Error(\n          \"Cannot use a CST node created by grammar '\" + cst.grammar.name +\n          \"' with a semantics for '\" + grammar.name + \"'\");\n    }\n    return s.wrap(cst);\n  };\n\n  // Forward public methods from the proxy to the semantics instance.\n  proxy.addOperation = function(nameAndFormalArgs, actionDict) {\n    s.addOperationOrAttribute.call(s, 'operation', nameAndFormalArgs, actionDict);\n    return proxy;\n  };\n  proxy.extendOperation = function(name, actionDict) {\n    s.extendOperationOrAttribute.call(s, 'operation', name, actionDict);\n    return proxy;\n  };\n  proxy.addAttribute = function(name, actionDict) {\n    s.addOperationOrAttribute.call(s, 'attribute', name, actionDict);\n    return proxy;\n  };\n  proxy.extendAttribute = function(name, actionDict) {\n    s.extendOperationOrAttribute.call(s, 'attribute', name, actionDict);\n    return proxy;\n  };\n\n  // Make the proxy's toString() work.\n  proxy.toString = s.toString.bind(s);\n\n  // Returns the semantics for the proxy.\n  proxy._getSemantics = function() {\n    return s;\n  };\n\n  return proxy;\n};\n\n// ----------------- Operation -----------------\n\n// An Operation represents a function to be applied to a concrete syntax tree (CST) -- it's very\n// similar to a Visitor (http://en.wikipedia.org/wiki/Visitor_pattern). An operation is executed by\n// recursively walking the CST, and at each node, invoking the matching semantic action from\n// `actionDict`. See `Operation.prototype.execute` for details of how a CST node's matching semantic\n// action is found.\nfunction Operation(name, formals, actionDict) {\n  this.name = name;\n  this.formals = formals;\n  this.actionDict = actionDict;\n}\n\nOperation.prototype.typeName = 'operation';\n\nOperation.prototype.checkActionDict = function(grammar) {\n  grammar._checkTopDownActionDict(this.typeName, this.name, this.actionDict);\n};\n\n// Execute this operation on the CST node associated with `nodeWrapper` in the context of the given\n// Semantics instance.\nOperation.prototype.execute = function(semantics, nodeWrapper) {\n  // Look for a semantic action whose name matches the node's constructor name, which is either the\n  // name of a rule in the grammar, or '_terminal' (for a terminal node), or '_iter' (for an\n  // iteration node). In the latter case, the action function receives a single argument, which is\n  // an array containing all of the children of the CST node.\n  var actionFn = this.actionDict[nodeWrapper._node.ctorName];\n  if (actionFn) {\n    return this.doAction(semantics, nodeWrapper, actionFn, nodeWrapper.isIteration());\n  }\n\n  // The action dictionary does not contain a semantic action for this specific type of node.\n  // If this is a nonterminal node and the programmer has provided a `_nonterminal` semantic\n  // action, we invoke it:\n  if (nodeWrapper.isNonterminal() && this.actionDict._nonterminal) {\n    actionFn = this.actionDict._nonterminal;\n    return this.doAction(semantics, nodeWrapper, actionFn, true);\n  }\n\n  // Otherwise, we invoke the '_default' semantic action.\n  return this.doAction(semantics, nodeWrapper, this.actionDict._default, true);\n};\n\n// Invoke `actionFn` on the CST node that corresponds to `nodeWrapper`, in the context of\n// `semantics`. If `optPassChildrenAsArray` is truthy, `actionFn` will be called with a single\n// argument, which is an array of wrappers. Otherwise, the number of arguments to `actionFn` will\n// be equal to the number of children in the CST node.\nOperation.prototype.doAction = function(semantics, nodeWrapper, actionFn, optPassChildrenAsArray) {\n  return optPassChildrenAsArray ?\n      actionFn.call(nodeWrapper, nodeWrapper._children()) :\n      actionFn.apply(nodeWrapper, nodeWrapper._children());\n};\n\n// ----------------- Attribute -----------------\n\n// Attributes are Operations whose results are memoized. This means that, for any given semantics,\n// the semantic action for a CST node will be invoked no more than once.\nfunction Attribute(name, actionDict) {\n  this.name = name;\n  this.formals = [];\n  this.actionDict = actionDict;\n}\ninherits(Attribute, Operation);\n\nAttribute.prototype.typeName = 'attribute';\n\nAttribute.prototype.execute = function(semantics, nodeWrapper) {\n  var node = nodeWrapper._node;\n  var key = semantics.attributeKeys[this.name];\n  if (!node.hasOwnProperty(key)) {\n    // The following is a super-send -- isn't JS beautiful? :/\n    node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);\n  }\n  return node[key];\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = Semantics;\n","deps":{"./MatchResult":"/Users/dubroy/dev/cdg/ohm/src/MatchResult.js","./common":"/Users/dubroy/dev/cdg/ohm/src/common.js","inherits":"/Users/dubroy/dev/cdg/ohm/node_modules/inherits/inherits_browser.js","es6-symbol":"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/index.js"},"file":"/Users/dubroy/dev/cdg/ohm/src/Semantics.js","sourceRoot":"file://localhost","sourceFile":"src/Semantics.js"},"/Users/dubroy/dev/cdg/ohm/dist/built-in-rules.js":{"id":"/Users/dubroy/dev/cdg/ohm/dist/built-in-rules.js","source":"var ohm = require('..');\nmodule.exports = ohm.makeRecipe(function() {\n  return new this.newGrammar(\"BuiltInRules\")\n    .define(\"alnum\", [], this.alt(this.app(\"letter\"), this.app(\"digit\")), \"an alpha-numeric character\")\n    .define(\"letter\", [], this.alt(this.app(\"lower\"), this.app(\"upper\"), this.app(\"unicodeLtmo\")), \"a letter\")\n    .define(\"digit\", [], this.range(\"0\", \"9\"), \"a digit\")\n    .define(\"hexDigit\", [], this.alt(this.app(\"digit\"), this.range(\"a\", \"f\"), this.range(\"A\", \"F\")), \"a hexadecimal digit\")\n    .define(\"ListOf_some\", [\"elem\", \"sep\"], this.seq(this.param(0), this.star(this.seq(this.param(1), this.param(0)))))\n    .define(\"ListOf_none\", [\"elem\", \"sep\"], this.seq())\n    .define(\"ListOf\", [\"elem\", \"sep\"], this.alt(this.app(\"ListOf_some\", [this.app(\"elem\"), this.app(\"sep\")]), this.app(\"ListOf_none\", [this.app(\"elem\"), this.app(\"sep\")])))\n    .define(\"listOf_some\", [\"elem\", \"sep\"], this.seq(this.param(0), this.star(this.seq(this.param(1), this.param(0)))))\n    .define(\"listOf_none\", [\"elem\", \"sep\"], this.seq())\n    .define(\"listOf\", [\"elem\", \"sep\"], this.alt(this.app(\"listOf_some\", [this.app(\"elem\"), this.app(\"sep\")]), this.app(\"listOf_none\", [this.app(\"elem\"), this.app(\"sep\")])))\n    .build();\n});\n\n","deps":{"..":"/Users/dubroy/dev/cdg/ohm/src/main.js"},"file":"/Users/dubroy/dev/cdg/ohm/dist/built-in-rules.js","sourceRoot":"file://localhost","sourceFile":"dist/built-in-rules.js"},"/Users/dubroy/dev/cdg/ohm/dist/operations-and-attributes.js":{"id":"/Users/dubroy/dev/cdg/ohm/dist/operations-and-attributes.js","source":"var ohm = require('..');\nmodule.exports = ohm.makeRecipe(function() {\n  return new this.newGrammar(\"OperationsAndAttributes\")\n    .withDefaultStartRule('NameNoFormals')\n    .define(\"NameNoFormals\", [], this.app(\"name\"))\n    .define(\"NameAndFormals\", [], this.seq(this.app(\"name\"), this.opt(this.app(\"Formals\"))))\n    .define(\"Formals\", [], this.seq(this.prim(\"(\"), this.app(\"ListOf\", [this.app(\"name\"), this.prim(\",\")]), this.prim(\")\")))\n    .define(\"name\", [], this.seq(this.app(\"nameFirst\"), this.star(this.app(\"nameRest\"))), \"a name\")\n    .define(\"nameFirst\", [], this.alt(this.prim(\"_\"), this.app(\"letter\")))\n    .define(\"nameRest\", [], this.alt(this.prim(\"_\"), this.app(\"alnum\")))\n    .build();\n});\n\n","deps":{"..":"/Users/dubroy/dev/cdg/ohm/src/main.js"},"file":"/Users/dubroy/dev/cdg/ohm/dist/operations-and-attributes.js","sourceRoot":"file://localhost","sourceFile":"dist/operations-and-attributes.js"},"/Users/dubroy/dev/cdg/ohm/dist/ohm-grammar.js":{"id":"/Users/dubroy/dev/cdg/ohm/dist/ohm-grammar.js","source":"var ohm = require('..');\nmodule.exports = ohm.makeRecipe(function() {\n  return new this.newGrammar(\"Ohm\")\n    .withDefaultStartRule('Grammars')\n    .define(\"Grammars\", [], this.star(this.app(\"Grammar\")))\n    .define(\"Grammar\", [], this.seq(this.app(\"ident\"), this.opt(this.app(\"SuperGrammar\")), this.prim(\"{\"), this.star(this.app(\"Rule\")), this.prim(\"}\")))\n    .define(\"SuperGrammar\", [], this.seq(this.prim(\"<:\"), this.app(\"ident\")))\n    .define(\"Rule_define\", [], this.seq(this.app(\"ident\"), this.opt(this.app(\"Formals\")), this.opt(this.app(\"ruleDescr\")), this.prim(\"=\"), this.app(\"Alt\")))\n    .define(\"Rule_override\", [], this.seq(this.app(\"ident\"), this.opt(this.app(\"Formals\")), this.prim(\":=\"), this.app(\"Alt\")))\n    .define(\"Rule_extend\", [], this.seq(this.app(\"ident\"), this.opt(this.app(\"Formals\")), this.prim(\"+=\"), this.app(\"Alt\")))\n    .define(\"Rule\", [], this.alt(this.app(\"Rule_define\"), this.app(\"Rule_override\"), this.app(\"Rule_extend\")))\n    .define(\"Formals\", [], this.seq(this.prim(\"<\"), this.app(\"ListOf\", [this.app(\"ident\"), this.prim(\",\")]), this.prim(\">\")))\n    .define(\"Params\", [], this.seq(this.prim(\"<\"), this.app(\"ListOf\", [this.app(\"Seq\"), this.prim(\",\")]), this.prim(\">\")))\n    .define(\"Alt\", [], this.seq(this.app(\"Term\"), this.star(this.seq(this.prim(\"|\"), this.app(\"Term\")))))\n    .define(\"Term_inline\", [], this.seq(this.app(\"Seq\"), this.app(\"caseName\")))\n    .define(\"Term\", [], this.alt(this.app(\"Term_inline\"), this.app(\"Seq\")))\n    .define(\"Seq\", [], this.star(this.app(\"Iter\")))\n    .define(\"Iter_star\", [], this.seq(this.app(\"Pred\"), this.prim(\"*\")))\n    .define(\"Iter_plus\", [], this.seq(this.app(\"Pred\"), this.prim(\"+\")))\n    .define(\"Iter_opt\", [], this.seq(this.app(\"Pred\"), this.prim(\"?\")))\n    .define(\"Iter\", [], this.alt(this.app(\"Iter_star\"), this.app(\"Iter_plus\"), this.app(\"Iter_opt\"), this.app(\"Pred\")))\n    .define(\"Pred_not\", [], this.seq(this.prim(\"~\"), this.app(\"Lex\")))\n    .define(\"Pred_lookahead\", [], this.seq(this.prim(\"&\"), this.app(\"Lex\")))\n    .define(\"Pred\", [], this.alt(this.app(\"Pred_not\"), this.app(\"Pred_lookahead\"), this.app(\"Lex\")))\n    .define(\"Lex_lex\", [], this.seq(this.prim(\"#\"), this.app(\"Base\")))\n    .define(\"Lex\", [], this.alt(this.app(\"Lex_lex\"), this.app(\"Base\")))\n    .define(\"Base_application\", [], this.seq(this.app(\"ident\"), this.opt(this.app(\"Params\")), this.not(this.alt(this.seq(this.opt(this.app(\"ruleDescr\")), this.prim(\"=\")), this.prim(\":=\"), this.prim(\"+=\")))))\n    .define(\"Base_range\", [], this.seq(this.app(\"Prim\"), this.prim(\"..\"), this.app(\"Prim\")))\n    .define(\"Base_prim\", [], this.app(\"Prim\"))\n    .define(\"Base_paren\", [], this.seq(this.prim(\"(\"), this.app(\"Alt\"), this.prim(\")\")))\n    .define(\"Base_arr\", [], this.seq(this.prim(\"[\"), this.app(\"Alt\"), this.prim(\"]\")))\n    .define(\"Base_str\", [], this.seq(this.prim(\"``\"), this.app(\"Alt\"), this.prim(\"''\")))\n    .define(\"Base_obj\", [], this.seq(this.prim(\"{\"), this.opt(this.prim(\"...\")), this.prim(\"}\")))\n    .define(\"Base_objWithProps\", [], this.seq(this.prim(\"{\"), this.app(\"Props\"), this.opt(this.seq(this.prim(\",\"), this.prim(\"...\"))), this.prim(\"}\")))\n    .define(\"Base\", [], this.alt(this.app(\"Base_application\"), this.app(\"Base_range\"), this.app(\"Base_prim\"), this.app(\"Base_paren\"), this.app(\"Base_arr\"), this.app(\"Base_str\"), this.app(\"Base_obj\"), this.app(\"Base_objWithProps\")))\n    .define(\"Prim\", [], this.alt(this.app(\"keyword\"), this.app(\"string\"), this.app(\"number\")))\n    .define(\"Props\", [], this.seq(this.app(\"Prop\"), this.star(this.seq(this.prim(\",\"), this.app(\"Prop\")))))\n    .define(\"Prop\", [], this.seq(this.alt(this.app(\"name\"), this.app(\"string\")), this.prim(\":\"), this.app(\"Alt\")))\n    .define(\"ruleDescr\", [], this.seq(this.prim(\"(\"), this.app(\"ruleDescrText\"), this.prim(\")\")), \"a rule description\")\n    .define(\"ruleDescrText\", [], this.star(this.seq(this.not(this.prim(\")\")), this.app(\"any\"))))\n    .define(\"caseName\", [], this.seq(this.prim(\"--\"), this.star(this.seq(this.not(this.prim(\"\\n\")), this.app(\"space\"))), this.app(\"name\"), this.star(this.seq(this.not(this.prim(\"\\n\")), this.app(\"space\"))), this.alt(this.prim(\"\\n\"), this.la(this.prim(\"}\")))))\n    .define(\"name\", [], this.seq(this.app(\"nameFirst\"), this.star(this.app(\"nameRest\"))), \"a name\")\n    .define(\"nameFirst\", [], this.alt(this.prim(\"_\"), this.app(\"letter\")))\n    .define(\"nameRest\", [], this.alt(this.prim(\"_\"), this.app(\"alnum\")))\n    .define(\"ident\", [], this.seq(this.not(this.app(\"keyword\")), this.app(\"name\")), \"an identifier\")\n    .define(\"keyword_null\", [], this.seq(this.prim(\"null\"), this.not(this.app(\"nameRest\"))))\n    .define(\"keyword_true\", [], this.seq(this.prim(\"true\"), this.not(this.app(\"nameRest\"))))\n    .define(\"keyword_false\", [], this.seq(this.prim(\"false\"), this.not(this.app(\"nameRest\"))))\n    .define(\"keyword\", [], this.alt(this.app(\"keyword_null\"), this.app(\"keyword_true\"), this.app(\"keyword_false\")))\n    .define(\"string\", [], this.seq(this.prim(\"\\\"\"), this.star(this.app(\"strChar\")), this.prim(\"\\\"\")))\n    .define(\"strChar\", [], this.alt(this.app(\"escapeChar\"), this.seq(this.not(this.prim(\"\\\\\")), this.not(this.prim(\"\\\"\")), this.not(this.prim(\"\\n\")), this.app(\"any\"))))\n    .define(\"escapeChar_backslash\", [], this.prim(\"\\\\\\\\\"))\n    .define(\"escapeChar_doubleQuote\", [], this.prim(\"\\\\\\\"\"))\n    .define(\"escapeChar_singleQuote\", [], this.prim(\"\\\\'\"))\n    .define(\"escapeChar_backspace\", [], this.prim(\"\\\\b\"))\n    .define(\"escapeChar_lineFeed\", [], this.prim(\"\\\\n\"))\n    .define(\"escapeChar_carriageReturn\", [], this.prim(\"\\\\r\"))\n    .define(\"escapeChar_tab\", [], this.prim(\"\\\\t\"))\n    .define(\"escapeChar_unicodeEscape\", [], this.seq(this.prim(\"\\\\u\"), this.app(\"hexDigit\"), this.app(\"hexDigit\"), this.app(\"hexDigit\"), this.app(\"hexDigit\")))\n    .define(\"escapeChar_hexEscape\", [], this.seq(this.prim(\"\\\\x\"), this.app(\"hexDigit\"), this.app(\"hexDigit\")))\n    .define(\"escapeChar\", [], this.alt(this.app(\"escapeChar_backslash\"), this.app(\"escapeChar_doubleQuote\"), this.app(\"escapeChar_singleQuote\"), this.app(\"escapeChar_backspace\"), this.app(\"escapeChar_lineFeed\"), this.app(\"escapeChar_carriageReturn\"), this.app(\"escapeChar_tab\"), this.app(\"escapeChar_unicodeEscape\"), this.app(\"escapeChar_hexEscape\")), \"an escape sequence\")\n    .define(\"number\", [], this.seq(this.opt(this.prim(\"-\")), this.plus(this.app(\"digit\"))), \"a number\")\n    .define(\"space_singleLine\", [], this.seq(this.prim(\"//\"), this.star(this.seq(this.not(this.prim(\"\\n\")), this.app(\"any\"))), this.prim(\"\\n\")))\n    .define(\"space_multiLine\", [], this.seq(this.prim(\"/*\"), this.star(this.seq(this.not(this.prim(\"*/\")), this.app(\"any\"))), this.prim(\"*/\")))\n    .extend(\"space\", [], this.alt(this.alt(this.app(\"space_singleLine\"), this.app(\"space_multiLine\")), this.range(\"\\u0000\", \" \")), \"a space\")\n    .build();\n});\n\n","deps":{"..":"/Users/dubroy/dev/cdg/ohm/src/main.js"},"file":"/Users/dubroy/dev/cdg/ohm/dist/ohm-grammar.js","sourceRoot":"file://localhost","sourceFile":"dist/ohm-grammar.js"}},"packages":{},"mtimes":{"/Users/dubroy/dev/cdg/ohm/dist/built-in-rules.js":1447700969000,"/Users/dubroy/dev/cdg/ohm/dist/ohm-grammar.js":1447701018000,"/Users/dubroy/dev/cdg/ohm/node_modules/browserify/lib/_empty.js":1438064813000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/index.js":1384515238000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/is-implemented.js":1422446487000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/is-symbol.js":1422280014000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/d/index.js":1382535396000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/index.js":1397548382000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/is-implemented.js":1397336021000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/assign/shim.js":1397389467000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/is-callable.js":1397838463000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/index.js":1392893968000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/is-implemented.js":1392894013000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/keys/shim.js":1392894104000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/normalize-options.js":1422876071000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/object/valid-value.js":1381161453000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/index.js":1392818598000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/is-implemented.js":1392818720000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/node_modules/es5-ext/string/#/contains/shim.js":1347534839000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/polyfill.js":1422455563000,"/Users/dubroy/dev/cdg/ohm/node_modules/es6-symbol/validate-symbol.js":1384513159000,"/Users/dubroy/dev/cdg/ohm/node_modules/inherits/inherits_browser.js":1368715198000,"/Users/dubroy/dev/cdg/ohm/node_modules/is-buffer/index.js":1414725590000,"/Users/dubroy/dev/cdg/ohm/node_modules/util-extend/extend.js":1361642144000,"/Users/dubroy/dev/cdg/ohm/src/Builder.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/Grammar.js":1442936268000,"/Users/dubroy/dev/cdg/ohm/src/GrammarDecl.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/InputStream.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/Interval.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/MatchResult.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/Namespace.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/PosInfo.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/Semantics.js":1447700893000,"/Users/dubroy/dev/cdg/ohm/src/State.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/Trace.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/common.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/errors.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/main.js":1442936268000,"/Users/dubroy/dev/cdg/ohm/src/nodes.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertAllApplicationsAreValid.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertChoicesHaveUniformArity.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-assertIteratedExprsAreNotNullable.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-check.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-eval.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-getArity.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-introduceParams.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-isNullable.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-outputRecipe.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-substituteParams.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-toDisplayString.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-toExpected.js":1441955681000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-toString.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/util.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/third_party/UnicodeCategories.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/node_modules/browserify/node_modules/process/browser.js":1441759817000,"/Users/dubroy/dev/cdg/ohm/src/fsets.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/Failure.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/src/pexprs-toFailure.js":1442601449000,"/Users/dubroy/dev/cdg/ohm/dist/operations-and-attributes.js":1447700969000},"filesPackagePaths":{},"dependentFiles":{}}